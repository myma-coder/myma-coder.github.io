<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>go基础学习 | My's Blog</title><meta name="keywords" content="go"><meta name="author" content="my"><meta name="copyright" content="my"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="go基础学习  注意事项   { 不能单独放在一行，否则会报错   在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。 如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。   标识符第一个字符必须是字母或下划线而不能是数字。   Go 语言的字符串可以通过">
<meta property="og:type" content="article">
<meta property="og:title" content="go基础学习">
<meta property="og:url" content="https://mylovewxy.live/posts/498781b7/index.html">
<meta property="og:site_name" content="My&#39;s Blog">
<meta property="og:description" content="go基础学习  注意事项   { 不能单独放在一行，否则会报错   在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。 如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。   标识符第一个字符必须是字母或下划线而不能是数字。   Go 语言的字符串可以通过">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/mywxy/image/master/PicxImage/xxx.6jdj6j8mns40.jpeg">
<meta property="article:published_time" content="2021-09-02T03:41:19.037Z">
<meta property="article:modified_time" content="2021-09-02T03:41:19.037Z">
<meta property="article:author" content="my">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/mywxy/image/master/PicxImage/xxx.6jdj6j8mns40.jpeg"><link rel="shortcut icon" href="https://gitee.com/mymywxy/pic-go/raw/master/img/20210102234642.png"><link rel="canonical" href="https://mylovewxy.live/posts/498781b7/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="HWj4HeAzpDuXluCc8U9l8XQCSLsGLizAuSWX2lSmfMk"/><meta name="baidu-site-verification" content="c9288e2323dadc71f0b9f364d0f0e5d1"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-02 03:41:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}const fontSizeVal = saveToLocal.get('global-font-size')
if (fontSizeVal !== undefined) {
  document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhheo/JS-Heo@main/bb/showbb_in_index.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2272279_9sosnv2poom.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC"><style type="text/css">#toggle-sidebar {left:100px}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><link rel="stylesheet" href="/news/css/news.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.css"/><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><script src="/live2d-widget/autoload.js"></script><!--<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">--><!--<script src="https://cdn.jsdelivr.net/gh/mywxy/live2d-widget@latest/autoload.js"></script>--><meta name="generator" content="Hexo 5.2.0"></head><body><a href="javascript:void(0);" onclick="preloader.endLoading();" title="点击跳过动画"><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="iron-container iron-circle"><div class="iron-box1 iron-circle iron-center"></div><div class="iron-box2 iron-circle iron-center"></div><div class="iron-box3 iron-circle iron-center"></div><div class="iron-box4 iron-circle iron-center"></div><div class="iron-box5 iron-circle iron-center"></div><div class="iron-box6 iron-circle"><div class="iron-coil" style="--i: 0"></div><div class="iron-coil" style="--i: 1"></div><div class="iron-coil" style="--i: 2"></div><div class="iron-coil" style="--i: 3"></div><div class="iron-coil" style="--i: 4"></div><div class="iron-coil" style="--i: 5"></div><div class="iron-coil" style="--i: 6"></div><div class="iron-coil" style="--i: 7"></div></div></div></div></a><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/mywxy/image@master/PicxImage/avatar.mih18dfv400.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-zhuye"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-wenjianjia"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-qingdan"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw iconfont icon-yinyue"></i><span> 音乐</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 相册</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 电影</span></a></li><li><a class="site-page" href="/bangumis/"><i class="fa-fw iconfont icon-bilibili-fill"></i><span> 追番</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-kongjian"></i><span> 空间</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/hpptalk/"><i class="fa-fw iconfont icon-41shuoshuo"></i><span> 说说</span></a></li><li><a class="site-page" href="/bb/"><i class="fa-fw iconfont icon-bbs"></i><span> 哔哔</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/fcircle/"><i class="fa-fw iconfont icon-lianjie"></i><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-wo"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-box"></i><span> 百宝箱</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/box/"><i class="fa-fw iconfont icon-daohang"></i><span> 导航页</span></a></li><li><a class="site-page" href="/game/2048/"><i class="fa-fw iconfont icon-Game"></i><span> 2048</span></a></li><li><a class="site-page" href="/game/catch-eat/"><i class="fa-fw iconfont icon-Game"></i><span> 圈小猫</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://mypan.mymywxy.workers.dev/"><i class="fa-fw iconfont icon-Game"></i><span> 个人网盘</span></a></li></ul></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://raw.githubusercontent.com/mywxy/image/master/PicxImage/xxx.6jdj6j8mns40.jpeg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">My's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-zhuye"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-shijianzhou"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-wenjianjia"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-qingdan"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw iconfont icon-yinyue"></i><span> 音乐</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw iconfont icon-xiangce"></i><span> 相册</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 电影</span></a></li><li><a class="site-page" href="/bangumis/"><i class="fa-fw iconfont icon-bilibili-fill"></i><span> 追番</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-kongjian"></i><span> 空间</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/hpptalk/"><i class="fa-fw iconfont icon-41shuoshuo"></i><span> 说说</span></a></li><li><a class="site-page" href="/bb/"><i class="fa-fw iconfont icon-bbs"></i><span> 哔哔</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/fcircle/"><i class="fa-fw iconfont icon-lianjie"></i><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw iconfont icon-wo"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw iconfont icon-box"></i><span> 百宝箱</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/box/"><i class="fa-fw iconfont icon-daohang"></i><span> 导航页</span></a></li><li><a class="site-page" href="/game/2048/"><i class="fa-fw iconfont icon-Game"></i><span> 2048</span></a></li><li><a class="site-page" href="/game/catch-eat/"><i class="fa-fw iconfont icon-Game"></i><span> 圈小猫</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="https://mypan.mymywxy.workers.dev/"><i class="fa-fw iconfont icon-Game"></i><span> 个人网盘</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">go基础学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-02T03:41:19.037Z" title="发表于 2021-09-02 03:41:19">2021-09-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-02T03:41:19.037Z" title="更新于 2021-09-02 03:41:19">2021-09-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/go%E8%AF%AD%E8%A8%80/">go语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>56分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="go基础学习"><a class="markdownIt-Anchor" href="#go基础学习"></a> go基础学习</h1>
<h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2>
<ol>
<li>
<p><strong>{</strong> 不能单独放在一行，否则会报错</p>
</li>
<li>
<p>在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。</p>
<p>如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。</p>
</li>
<li>
<p>标识符第一个字符必须是字母或下划线而不能是数字。</p>
</li>
<li>
<p>Go 语言的字符串可以通过 <strong>+</strong> 实现拼接 eg:  fmt.Println(“Google” + “Runoob”)</p>
</li>
</ol>
<h2 id="标记"><a class="markdownIt-Anchor" href="#标记"></a> 标记</h2>
<p>布尔型：<code>t</code> 整　型：<code>d</code> 浮点型：<code>g</code> 复数型：<code>g</code> 字符串：<code>s</code> 通　道：<code>p</code> 指　针：<code>p</code></p>
<p>无符号整型：x</p>
<p>-<code>t</code> ：输出 true 或 false 字符串。</p>
<ul>
<li><code>b/o/d</code>：输出 2/8/10 进制格式</li>
<li><code>x/X</code>：输出 16 进制格式（小写/大写）</li>
<li><code>c</code>：输出数值所表示的 Unicode 字符</li>
<li><code>q</code>：输出数值所表示的 Unicode 字符（带单引号）。对于无法显示的字符，将输出其转义字符。</li>
<li><code>U</code>：输出 Unicode 码点（例如 U+1234，等同于字符串 “U+%04X” 的显示结果）</li>
</ul>
<p>对于 o/x/X：</p>
<ul>
<li>如果使用 “#” 标记，则会添加前导 0 或 0x。</li>
</ul>
<p>对于 U：</p>
<ul>
<li>如果使用 “#” 标记，则会在 Unicode 码点后面添加相应的 ‘字符’（前提是该字符必须可显示）</li>
</ul>
<p>浮点型和复数型<code>b</code>：科学计数法（以 2 为底）<code>e/E</code>：科学计数法（以 10 为底，小写 e/大写 E）<code>f/F</code>：普通小数格式（两者无区别）<code>g/G</code>：大指数（指数 &gt;= 6）使用 %e/%E，其它情况使用 %f/%F</p>
<p>字符串或字节切片</p>
<ul>
<li><code>s</code> ：普通字符串</li>
<li><code>q</code> ：双引号引起来的 Go 语法字符串</li>
<li><code>x/X</code>：十六进制编码（小写/大写，以字节为元素进行编码，而不是字符）</li>
</ul>
<p>对于 q：</p>
<ul>
<li>如果使用了 <code>+</code> 标记，则将所有非 ASCII 字符都进行转义处理。</li>
<li>如果使用了 <code>#</code> 标记，则输出反引号引起来的字符串（前提是</li>
<li>字符串中不包含任何制表符以外的控制字符，否则忽略 # 标记）</li>
</ul>
<p>对于 x/X：</p>
<ul>
<li>如果使用了 &quot; &quot; 标记，则在每个元素之间添加空格。</li>
<li>如果使用了 “#” 标记，则在十六进制格式之前添加 0x 前缀。</li>
</ul>
<p>指针类型<code>p</code> ：带 0x 前缀的十六进制地址值。<code>#p</code>：不带 0x 前缀的十六进制地址值。Go 没有指针运算。</p>
<h2 id="内置关键字"><a class="markdownIt-Anchor" href="#内置关键字"></a> 内置关键字</h2>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>      <span class="keyword">default</span>       func      <span class="keyword">interface</span>    <span class="symbol">selectcase</span>       <span class="symbol">defer</span>         <span class="symbol">go</span>        <span class="symbol">map</span>          <span class="symbol">structchan</span>       <span class="symbol">else</span>          <span class="symbol">goto</span>      <span class="symbol">package</span>      <span class="symbol">switchconst</span>      <span class="symbol">fallthrough</span>   <span class="symbol">if</span>        <span class="symbol">range</span>        <span class="symbol">typecontinue</span>   <span class="symbol">for</span>           <span class="symbol">import</span>    <span class="symbol">return</span>       <span class="symbol">var</span></span><br></pre></td></tr></table></figure>
<h2 id="预定义标识符"><a class="markdownIt-Anchor" href="#预定义标识符"></a> 预定义标识符</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">append</span>  <span class="keyword">bool</span>    <span class="keyword">byte</span>    <span class="built_in">cap</span>     <span class="built_in">close</span>  <span class="built_in">complex</span> <span class="keyword">complex64</span> <span class="keyword">complex128</span> uint16copy    <span class="literal">false</span>   <span class="keyword">float32</span> <span class="keyword">float64</span> <span class="built_in">imag</span>   <span class="keyword">int</span>     <span class="keyword">int8</span>      <span class="keyword">int16</span>      uint32int32   <span class="keyword">int64</span>   <span class="literal">iota</span>    <span class="built_in">len</span>     <span class="built_in">make</span>   <span class="built_in">new</span>     <span class="literal">nil</span>       <span class="built_in">panic</span>      uint64print   <span class="built_in">println</span> <span class="built_in">real</span>    <span class="built_in">recover</span> <span class="keyword">string</span> <span class="literal">true</span>    <span class="keyword">uint</span>      <span class="keyword">uint8</span>      <span class="keyword">uintptr</span></span><br></pre></td></tr></table></figure>
<h2 id="包变量函数"><a class="markdownIt-Anchor" href="#包变量函数"></a> 包，变量，函数</h2>
<h3 id="导出名"><a class="markdownIt-Anchor" href="#导出名"></a> 导出名</h3>
<p>在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，Pizza 就是个已导出名，Pi 也同样，它导出自 math 包。</p>
<h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3>
<p>函数可以没有参数或接受多个参数。</p>
<p>eg：</p>
<p>func add(x int, y int) int {</p>
<p>return x + y</p>
<p>}</p>
<p>注意：参数类型在变量名后面</p>
<p>当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。</p>
<p>在本例中，x int, y int被缩写为x, y int</p>
<p><strong>多值返回</strong></p>
<p>函数可以返回任意数量的返回值。</p>
<p>swap 函数返回了两个字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;	<span class="keyword">return</span> y, x&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️：返回值类型在参数后面</p>
<h3 id="命名返回值"><a class="markdownIt-Anchor" href="#命名返回值"></a> 命名返回值</h3>
<p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</p>
<p>返回值的名称应当具有一定的意义，它可以作为文档使用。</p>
<p>没有参数的 <code>return</code> 语句返回已命名的返回值。也就是 <code>直接</code> 返回。</p>
<p>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;	x = sum * <span class="number">4</span> / <span class="number">9</span>	y = sum - x	<span class="keyword">return</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3>
<p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后</p>
<p>eg: var c, python, java bool</p>
<h3 id="变量的初始化"><a class="markdownIt-Anchor" href="#变量的初始化"></a> 变量的初始化</h3>
<p>变量声明可以包含初始值，每个变量对应一个。</p>
<p><strong>如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。</strong></p>
<p>var i, j int = 1, 2</p>
<p>var c, python, java = true, false, “no!”</p>
<p>在函数中，简洁赋值语句 <code>:=</code> 可在类型明确的地方代替 <code>var</code> 声明。</p>
<p>⚠️函数外的每个语句都必须以关键字开始（<code>var</code>, <code>func</code> 等等），因此 <code>:=</code> 结构不能在函数外使用</p>
<h3 id="基本类型"><a class="markdownIt-Anchor" href="#基本类型"></a> 基本类型</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolstringint  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  int64uint <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> uintptrbyte <span class="comment">// uint8 的别名rune // int32 的别名    // 表示一个 Unicode 码点float32 float64complex64 complex128</span></span><br></pre></td></tr></table></figure>
<p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p>
<h4 id="整型"><a class="markdownIt-Anchor" href="#整型"></a> 整型</h4>
<p><img src="https://i.loli.net/2021/07/06/fQvShWuwHKVskne.png" alt="image-20210706114603625" /></p>
<h4 id="不同进制表示"><a class="markdownIt-Anchor" href="#不同进制表示"></a> 不同进制表示</h4>
<p>2进制：以<code>0b</code>或<code>0B</code>为前缀</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> num01 int = <span class="number">0b1100</span></span><br></pre></td></tr></table></figure>
<p>8进制：以<code>0o</code>或者 <code>0O</code>为前缀</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var</span> num<span class="number">02</span> int = <span class="number">0</span>o<span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>16进制：以<code>0x</code> 为前缀</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var</span> num<span class="number">03</span> int = <span class="number">0</span>xC</span><br></pre></td></tr></table></figure>
<h4 id="fmt包"><a class="markdownIt-Anchor" href="#fmt包"></a> fmt包</h4>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%b    表示为二进制%c    该值对应的unicode码值%d    表示为十进制%o    表示为八进制%q    该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示%x    表示为十六进制，使用a-f%X    表示为十六进制，使用A-F%U    表示为Unicode格式：U+<span class="number">1234</span>，等价于<span class="string">&quot;U+%04X&quot;</span>%E    用科学计数法表示%f    用浮点数表示</span><br></pre></td></tr></table></figure>
<h4 id="浮点数"><a class="markdownIt-Anchor" href="#浮点数"></a> 浮点数</h4>
<p>Go语言里，浮点数的相关部分只能由10进制表示法表示，而不能由8进制表示法或16进制表示法表示。比如，<code>03.7</code>表示的一定是浮点数<code>3.7</code>。</p>
<p>Go语言中提供了两种精度的浮点数 float32 和 float64。</p>
<p><strong>float32</strong>，也即我们常说的单精度，存储占用4个字节，也即4*8=32位，其中1位用来符号，8位用来指数，剩下的23位表示尾数</p>
<p><img src="https://pic4.zhimg.com/80/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.jpg" alt="img" /></p>
<p><strong>float64</strong>，也即我们熟悉的双精度，存储占用8个字节，也即8*8=64位，其中1位用来符号，11位用来指数，剩下的52位表示尾数</p>
<p><img src="https://i.loli.net/2021/07/06/NjQS8pAryJqhcIa.png" alt="img" /></p>
<p>精度主要取决于尾数部分的位数。</p>
<p>对于 float32（单精度）来说，表示尾数的为23位，除去全部为0的情况以外，最小为2<sup>-23，约等于1.19*10</sup>-7，所以float小数部分只能精确到后面6位，加上小数点前的一位，即有效数字为7位。</p>
<p>同理 float64（单精度）的尾数部分为 52位，最小为2<sup>-52，约为2.22*10</sup>-16，所以精确到小数点后15位，加上小数点前的一位，有效位数为16位。</p>
<p><strong>一、float32 和 float64 可以表示的数值很多</strong></p>
<p>浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 math 包中找到：</p>
<ul>
<li>常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38；</li>
<li>常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308；</li>
<li>float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。</li>
</ul>
<p><strong>二、数值很大但精度有限</strong></p>
<p>人家虽然能表示的数值很大，但精度位却没有那么大。</p>
<ul>
<li>float32的精度只能提供大约6个十进制数（表示后科学计数法后，小数点后6位）的精度</li>
<li>float64的精度能提供大约15个十进制数（表示后科学计数法后，小数点后15位）的精度</li>
</ul>
<p>比如 10000018这个数，用 float32 的类型来表示的话，由于其有效位是7位，将10000018 表示成科学计数法，就是 1.0000018 * 10^7，能精确到小数点后面6位。</p>
<p>此时用科学计数法表示后，小数点后有7位，刚刚满足我们的精度要求，意思是什么呢？此时你对这个数进行+1或者-1等数学运算，都能保证计算结果是精确的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span><span class="keyword">var</span> myfloat <span class="keyword">float32</span> = <span class="number">10000018</span><span class="keyword">func</span> main()  &#123;    fmt.Println(<span class="string">&quot;myfloat: &quot;</span>, myfloat)    fmt.Println(<span class="string">&quot;myfloat: &quot;</span>, myfloat+<span class="number">1</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">myfloat</span>:  <span class="number">1</span>.<span class="number">0000018</span>e+<span class="number">07</span>myfloat:  <span class="number">1</span>.<span class="number">0000019</span>e+<span class="number">07</span></span><br></pre></td></tr></table></figure>
<p>上面举了一个刚好满足精度要求数据的临界情况，为了做对比，下面也举一个刚好不满足精度要求的例子。只要给这个数值多加一位数就行了。</p>
<p>换成 100000187，同样使用 float32类型，表示成科学计数法，由于精度有限，表示的时候小数点后面7位是准确的，但若是对其进行数学运算，由于第八位无法表示，所以运算后第七位的值，就会变得不精确。</p>
<p>这里我们写个代码来验证一下，按照我们的理解下面 myfloat01 = 100000182 ，对其<code>+5</code> 操作后，应该等于 myfloat02 = 100000187，</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">import</span> <span class="string">&quot;fmt&quot;</span>var myfloat<span class="number">01</span> float<span class="number">32</span> = <span class="number">100000182</span>var myfloat<span class="number">02</span> float<span class="number">32</span> = <span class="number">100000187</span>func main() &#123;    fmt.Println(<span class="string">&quot;myfloat: &quot;</span>, myfloat<span class="number">01</span>)    fmt.Println(<span class="string">&quot;myfloat: &quot;</span>, myfloat<span class="number">01</span>+<span class="number">5</span>)    fmt.Println(myfloat<span class="number">02</span> == myfloat<span class="number">01</span>+<span class="number">5</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>但是由于其类型是 float32，精度不足，导致最后比较的结果是不相等（从小数点后第七位开始不精确）</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">myfloat</span>:  <span class="number">1</span>.<span class="number">00000184</span>e+<span class="number">08</span>myfloat:  <span class="number">1</span>.<span class="number">0000019</span>e+<span class="number">08</span>false</span><br></pre></td></tr></table></figure>
<p>由于精度的问题，就会出现这种很怪异的现象，<code>myfloat == myfloat +1</code> 会返回 <code>true</code> 。</p>
<h4 id="byte-与-rune"><a class="markdownIt-Anchor" href="#byte-与-rune"></a> byte 与 rune</h4>
<p><strong>byte</strong>，占用1个节字，就 8 个比特位（2^8 = 256，因此 byte 的表示范围 0-&gt;255），所以它和 <code>uint8</code> 类型本质上没有区别，它表示的是 <strong>ACSII</strong> 表中的一个字符。</p>
<p><strong>rune</strong>，占用4个字节，共32位比特位，所以它和 <code>uint32</code> 本质上也没有区别。它表示的是一个 <strong>Unicode字符</strong>（Unicode是一个可以表示世界范围内的绝大部分字符的编码规范）。</p>
<p>⚠️Go 中单引号与 双引号并不是等价的，单引号用来表示字符，双引号表示字符串</p>
<h4 id="string"><a class="markdownIt-Anchor" href="#string"></a> string</h4>
<p>string 的本质，其实是一个 byte数组。</p>
<p>Go 语言的 string 是用 uft-8 进行编码的，英文字母占用一个字节，而中文字母占用 3个字节。</p>
<p>除了双引号之外 ，还可以使用反引号表示字符串。</p>
<p>大多情况下，二者并没有区别，但如果你的字符串中有转义字符<code>\</code> ，这里就要注意了，它们是有区别的。</p>
<p>使用反引号包裹的字符串，相当于 Python 中的 raw 字符串，会忽略里面的转义。</p>
<p>比如我想表示 <code>\r\n</code> 这个 字符串，使用双引号是这样写的，这种叫<strong>解释型表示法</strong></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var mystr01 <span class="type">string</span> = <span class="string">&quot;<span class="subst">\\</span>r<span class="subst">\\</span>n&quot;</span></span><br></pre></td></tr></table></figure>
<p>而使用反引号，就方便多了，所见即所得，这种叫<strong>原生型表示法</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mystr02 <span class="keyword">string</span> = <span class="string">`\r\n`</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mport (    <span class="string">&quot;fmt&quot;</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">var</span> mystr01 <span class="keyword">string</span> = <span class="string">&quot;\\r\\n&quot;</span>    <span class="keyword">var</span> mystr02 <span class="keyword">string</span> = <span class="string">`\r\n`</span>    fmt.Println(mystr01)    fmt.Println(mystr02)&#125;<span class="comment">// output\r\n\r\n</span></span><br></pre></td></tr></table></figure>
<p>如果你仍然想使用解释型的字符串，但是各种转义实在太麻烦了。你可以使用 fmt 的 <code>%q</code> 来还原一下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (    <span class="string">&quot;fmt&quot;</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">var</span> mystr01 <span class="keyword">string</span> = <span class="string">`\r\n`</span>    fmt.Print(<span class="string">`\r\n`</span>)    fmt.Printf(<span class="string">&quot;的解释型字符串是： %q&quot;</span>, mystr01)&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span>的解释型字符串是： &quot;<span class="symbol">\\</span>r<span class="symbol">\\</span>n&quot;</span><br></pre></td></tr></table></figure>
<p>同时反引号可以不写换行符（因为没法写）来表示一个多行的字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (    <span class="string">&quot;fmt&quot;</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">var</span> mystr01 <span class="keyword">string</span> = <span class="string">`你好呀!我的公众号是: Go编程时光，欢迎大家关注`</span>    fmt.Println(mystr01)&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好呀!我的公众号是: Go编程时光，欢迎大家关注</span><br></pre></td></tr></table></figure>
<h4 id="布尔类型"><a class="markdownIt-Anchor" href="#布尔类型"></a> 布尔类型</h4>
<p>在 Go 中，真值用 true 表示，不但不与 1 相等，并且更加严格，不同类型无法进行比较，而假值用 false 表示，同样与 0 无法比较。</p>
<h3 id="零值"><a class="markdownIt-Anchor" href="#零值"></a> 零值</h3>
<p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p>
<p>零值是：</p>
<ul>
<li>数值类型为 <code>0</code>，</li>
<li>布尔类型为 <code>false</code>，</li>
<li>字符串为 <code>&quot;&quot;</code>（空字符串）。</li>
</ul>
<h3 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h3>
<p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</p>
<p>一些关于数值的转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">42</span><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="keyword">float64</span>(i)<span class="keyword">var</span> u <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</span><br></pre></td></tr></table></figure>
<p>或者，更加简单的形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span>f := <span class="keyword">float64</span>(i)u := <span class="keyword">uint</span>(f)</span><br></pre></td></tr></table></figure>
<p>与 C 不同的是，Go 在不同类型的项之间赋值时需要<strong>显式转换</strong>。</p>
<h3 id="类型推导"><a class="markdownIt-Anchor" href="#类型推导"></a> 类型推导</h3>
<p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var =</code> 表达式语法），变量的类型由右值推导得出。</p>
<p>当右值声明了类型时，新变量的类型与其相同：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">i</span> intj := <span class="selector-tag">i</span> <span class="comment">// j 也是一个 int</span></span><br></pre></td></tr></table></figure>
<p>不过当右边包含<strong>未指明类型的数值常量</strong>时，新变量的类型就可能是 <code>int</code>, <code>float64</code>或 <code>complex128</code> 了，这取决于常量的精度：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">i</span> := <span class="number">42</span>           // intf := <span class="number">3</span>.<span class="number">142</span>        // float<span class="number">64</span>g := <span class="number">0</span>.<span class="number">867</span> + <span class="number">0</span>.<span class="number">5</span>i // complex<span class="number">128</span></span><br></pre></td></tr></table></figure>
<p>%v 变量值  %T  变量类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	v := <span class="number">0.867</span> + <span class="number">0.5i</span><span class="comment">// 修改这里！	fmt.Printf(&quot;v is of type %T\n&quot;, v)&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h3>
<p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字。</p>
<p>常量可以是字符、字符串、布尔值或数值。</p>
<p>⚠️常量不能用 <code>:=</code> 语法声明。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> World = <span class="string">&quot;世界&quot;</span>	fmt.Println(<span class="string">&quot;Hello&quot;</span>, World)	fmt.Println(<span class="string">&quot;Happy&quot;</span>, Pi, <span class="string">&quot;Day&quot;</span>)	<span class="keyword">const</span> Truth = <span class="literal">true</span>	fmt.Println(<span class="string">&quot;Go rules?&quot;</span>, Truth)</span><br></pre></td></tr></table></figure>
<p>⚠️go中打印字符串拼接直接用,隔开即可</p>
<p>iota枚举，常量自动生成器，自动加一</p>
<h3 id="数值常量"><a class="markdownIt-Anchor" href="#数值常量"></a> 数值常量</h3>
<p>数值常量是高精度的 <strong>值</strong>。</p>
<p>一个未指定类型的常量由上下文来决定其类型。</p>
<p>再尝试一下输出 <code>needInt(Big)</code> 吧。</p>
<p>（<code>int</code> 类型最大可以存储一个 64 位的整数，有时会更小。）</p>
<p>（<code>int</code> 可以存放最大64位的整数，根据平台不同有时会更少。）</p>
<h3 id="五种变量声明的方法"><a class="markdownIt-Anchor" href="#五种变量声明的方法"></a> 五种变量声明的方法</h3>
<h4 id="1-一行声明一个变量"><a class="markdownIt-Anchor" href="#1-一行声明一个变量"></a> 1. 一行声明一个变量</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;name&gt; &lt;<span class="keyword">type</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2多个变量一起声明"><a class="markdownIt-Anchor" href="#2多个变量一起声明"></a> 2.多个变量一起声明</h4>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (    name <span class="built_in">string</span>    age <span class="built_in">int</span>    gender <span class="built_in">string</span>)</span><br></pre></td></tr></table></figure>
<h4 id="3-声明和初始化一个变量"><a class="markdownIt-Anchor" href="#3-声明和初始化一个变量"></a> 3. 声明和初始化一个变量</h4>
<p>使用 <code>:=</code> （推导声明写法或者短类型声明法：编译器会自动根据右值类型推断出左值的对应类型。），可以声明一个变量，并对其进行（显式）初始化。但这种方法有个限制就是，只能用于函数内部。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">&quot;Go编程时光&quot;</span><span class="regexp">//</span> 等价于var name string = <span class="string">&quot;Go编程时光&quot;</span><span class="regexp">//</span> 等价于var name = <span class="string">&quot;Go编程时光&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-声明和初始化多个变量"><a class="markdownIt-Anchor" href="#4-声明和初始化多个变量"></a> 4. 声明和初始化多个变量</h4>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">name</span>, age := <span class="string">&quot;wangbm&quot;</span>, <span class="number">28</span></span><br></pre></td></tr></table></figure>
<p>这种方法，也经常用于变量的交换</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> int = <span class="number">100</span>var <span class="selector-tag">b</span> int = <span class="number">200</span>b, <span class="selector-tag">a</span> = <span class="selector-tag">a</span>, b</span><br></pre></td></tr></table></figure>
<h4 id="5-new-函数声明一个指针变量"><a class="markdownIt-Anchor" href="#5-new-函数声明一个指针变量"></a> 5. new 函数声明一个指针变量</h4>
<p>变量分为两种 <code>普通变量</code> 和 <code>指针变量</code></p>
<p>普通变量，存放的是数据本身，而指针变量存放的是数据的地址。</p>
<p>new 函数，是 Go 里的一个内建函数。</p>
<p>使用表达式 new(Type) 将创建一个Type类型的匿名变量，初始化为Type类型的零值，然后返回变量地址，返回的指针类型为<code>*Type</code>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">package</span> <span class="selector-tag">mainimport</span> &quot;<span class="selector-tag">fmt</span>&quot;<span class="selector-tag">func</span> <span class="selector-tag">main</span>()  &#123;    <span class="attribute">ptr </span>:= <span class="built_in">new</span>(int)    fmt.<span class="built_in">Println</span>(<span class="string">&quot;ptr address: &quot;</span>, ptr)    fmt.<span class="built_in">Println</span>(<span class="string">&quot;ptr value: &quot;</span>, *ptr)  // * 后面接指针变量，表示从内存地址中取出值&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ptr</span> address:  <span class="number">0</span>xc<span class="number">000010098</span>ptr value:  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(Type)。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。</p>
<p>如下两种写法，可以说是等价的</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 使用 newfunc newInt() *<span class="built_in">int</span> &#123;    <span class="keyword">return</span> new(<span class="built_in">int</span>)&#125;// 使用传统的方式<span class="keyword">func</span> newInt() *<span class="built_in">int</span> &#123;    <span class="keyword">var</span> dummy <span class="built_in">int</span>    <span class="keyword">return</span> &amp;dummy&#125;</span><br></pre></td></tr></table></figure>
<p>以上不管哪种方法，变量/常量都只能声明一次，声明多次，编译就会报错。</p>
<p>但也有例外，这就要说到一个特殊变量：<strong>匿名变量</strong>，也称作占位符，或者空白标识符，用下划线表示。</p>
<p>匿名变量，优点有三：</p>
<ul>
<li>不分配内存，不占用内存空间</li>
<li>不需要你为命名无用的变量名而纠结</li>
<li>多次声明不会有任何问题</li>
</ul>
<p>通常我们用匿名接收必须接收，但是又不会用到的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;    a, _ := GetData()    _, b := GetData()    fmt.Println(a, b)&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="流程控制"><a class="markdownIt-Anchor" href="#流程控制"></a> 流程控制</h2>
<h3 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h3>
<p>Go 只有一种循环结构：<code>for</code> 循环。</p>
<p>基本的 <code>for</code> 循环由三部分组成，它们用分号隔开：</p>
<ul>
<li>初始化语句：在第一次迭代前执行</li>
<li>条件表达式：在每次迭代前求值</li>
<li>后置语句：在每次迭代的结尾执行</li>
</ul>
<p>初始化语句通常为一句<strong>短变量声明</strong>，该变量声明仅在 <code>for</code> 语句的作用域中可见。⚠️此处不允许var声明</p>
<p>一旦条件表达式的布尔值为 <code>false</code>，循环迭代就会终止。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;		sum += i		fmt.Println(sum)	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 <code>&#123; &#125;</code> 则是必须的。</p>
<p>初始化语句和后置语句是<strong>可选的</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;		sum += sum	&#125;</span><br></pre></td></tr></table></figure>
<p>for 是 Go 中的 “while”</p>
<p>此时你可以去掉分号，因为 C 的 <code>while</code> 在 Go 中叫做 <code>for</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;		sum += sum	&#125;</span><br></pre></td></tr></table></figure>
<p>如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="if"><a class="markdownIt-Anchor" href="#if"></a> if</h3>
<p>Go 的 <code>if</code> 语句与 <code>for</code> 循环类似，表达式外无需小括号 <code>( )</code> ，而大括号 <code>&#123; &#125;</code> 则是必须的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;		<span class="keyword">return</span> sqrt(-x) + <span class="string">&quot;i&quot;</span>	&#125;</span><br></pre></td></tr></table></figure>
<p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句。</p>
<p>该语句声明的变量作用域仅在 <code>if</code> 之内。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;		<span class="keyword">return</span> v	&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;		<span class="keyword">return</span> v	&#125; <span class="keyword">else</span> &#123;		fmt.Printf(<span class="string">&quot;%g &gt;= %g\n&quot;</span>, v, lim)	&#125;	<span class="comment">// 这里开始就不能使用 v 了	return lim</span></span><br></pre></td></tr></table></figure>
<h3 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h3>
<h4 id="循环与函数"><a class="markdownIt-Anchor" href="#循环与函数"></a> 循环与函数</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;	z:=x/<span class="number">2</span>	pre:=<span class="keyword">float64</span>(<span class="number">0</span>)	i:=<span class="number">1</span>;	<span class="keyword">for</span> pre!=z&#123;		pre = z;		z-=(z*z-x)/(<span class="number">2</span>*z)		fmt.Println(i,<span class="string">&quot;  &quot;</span>,z)		i++;	&#125;	<span class="keyword">return</span> z&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch"><a class="markdownIt-Anchor" href="#switch"></a> switch</h3>
<p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p>
<p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句。 除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (	<span class="string">&quot;fmt&quot;</span>	<span class="string">&quot;runtime&quot;</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	fmt.Print(<span class="string">&quot;Go runs on &quot;</span>)	<span class="keyword">switch</span> os := runtime.GOOS; os &#123;	<span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:		fmt.Println(<span class="string">&quot;OS X.&quot;</span>)	<span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:		fmt.Println(<span class="string">&quot;Linux.&quot;</span>)		<span class="keyword">fallthrough</span>	<span class="keyword">default</span>:		<span class="comment">// freebsd, openbsd,		// plan9, windows...		fmt.Printf(&quot;%s.\n&quot;, os)	&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>switch 的求值顺序</p>
<p>switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。</p>
<p>（例如，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> i &#123;<span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">case</span> f():&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>i==0</code> 时 <code>f</code> 不会被调用。）</p>
<h4 id="一个-case-多个条件"><a class="markdownIt-Anchor" href="#一个-case-多个条件"></a> 一个 case 多个条件</h4>
<p>case 后可以接多个多个条件，多个条件之间是 <code>或</code> 的关系，用逗号相隔。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    month := <span class="number">2</span>    <span class="keyword">switch</span> month &#123;    <span class="keyword">case</span> <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>:        fmt.Println(<span class="string">&quot;春天&quot;</span>)    <span class="keyword">case</span> <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>:        fmt.Println(<span class="string">&quot;夏天&quot;</span>)    <span class="keyword">case</span> <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>:        fmt.Println(<span class="string">&quot;秋天&quot;</span>)    <span class="keyword">case</span> <span class="number">12</span>, <span class="number">1</span>, <span class="number">2</span>:        fmt.Println(<span class="string">&quot;冬天&quot;</span>)    <span class="keyword">default</span>:        fmt.Println(<span class="string">&quot;输入有误...&quot;</span>)    &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="switch-后可接函数"><a class="markdownIt-Anchor" href="#switch-后可接函数"></a> switch 后可接函数</h4>
<p>switch 后面可以接一个函数，只要保证 case 后的值类型与函数的返回值 一致即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span><span class="comment">// 判断一个同学是否有挂科记录的函数// 返回值是布尔类型func getResult(args ...int) bool &#123;    for _, i := range args &#123;        if i &lt; 60 &#123;            return false        &#125;    &#125;    return true&#125;func main() &#123;    chinese := 80    english := 50    math := 100    switch getResult(chinese, english, math) &#123;    // case 后也必须 是布尔类型    case true:        fmt.Println(&quot;该同学所有成绩都合格&quot;)    case false:        fmt.Println(&quot;该同学有挂科记录&quot;)    &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="case-使用关键字-fallthrough-开启穿透能力"><a class="markdownIt-Anchor" href="#case-使用关键字-fallthrough-开启穿透能力"></a> case 使用关键字 <code>fallthrough</code> 开启穿透能力</h4>
<h3 id="没有条件的-switch"><a class="markdownIt-Anchor" href="#没有条件的-switch"></a> 没有条件的 switch</h3>
<p>没有条件的 switch 同 <code>switch true</code> 一样。</p>
<p>这种形式能将一长串 if-then-else 写得更加清晰。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	t := time.Now()	<span class="keyword">switch</span> &#123;	<span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:		fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)	<span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:		fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)	<span class="keyword">default</span>:		fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)	&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="defer"><a class="markdownIt-Anchor" href="#defer"></a> defer</h3>
<p>defer 语句会将函数推迟到外层函数返回之后执行。</p>
<p><strong>是即时求值的变量快照</strong></p>
<p>使用 defer 只是延时调用函数，此时传递给函数里的变量，不应该受到后续程序的影响。</p>
<p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)	fmt.Println(<span class="string">&quot;hello&quot;</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>defer 栈</p>
<p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p>
<p>⚠️defer 是return 后才调用的。</p>
<h3 id="goto"><a class="markdownIt-Anchor" href="#goto"></a> goto</h3>
<p>goto 后接一个标签，这个标签的意义是告诉 Go程序下一步要执行哪里的代码。</p>
<p><code>goto</code> 可以打破原有代码执行顺序，直接跳转到某一行执行代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">goto</span> flag    fmt.Println(<span class="string">&quot;B&quot;</span>)flag:    fmt.Println(<span class="string">&quot;A&quot;</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果，并不会输出 B ，而只会输出 A</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure>
<p><code>goto</code> 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。</p>
<p>这边举一个例子，用 <code>goto</code> 的方式来实现一个打印 1到5 的循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    i := <span class="number">1</span>flag:    <span class="keyword">if</span> i &lt;= <span class="number">5</span> &#123;        fmt.Println(i)        i++        <span class="keyword">goto</span> flag    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️goto语句与标签之间不能有变量声明，否则编译错误。</p>
<h2 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h2>
<h4 id="创建方式"><a class="markdownIt-Anchor" href="#创建方式"></a> 创建方式</h4>
<p><strong>第一种方法</strong></p>
<p>先定义对应的变量，再通过变量取得内存地址，创建指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义普通变量a int := 1// 定义指针变量ptr := &amp;a int</span></span><br></pre></td></tr></table></figure>
<p><strong>第二种方法</strong></p>
<p>先创建指针，分配好内存后，再给指针指向的内存地址写入对应的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建指针astr := new(string)// 给指针赋值*astr = &quot;Go编程时光&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>第三种方法</strong></p>
<p>先声明一个指针变量，再从其他变量取得内存地址赋值给它</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aint := <span class="number">1</span><span class="keyword">var</span> bint *<span class="keyword">int</span>  <span class="comment">// 声明一个指针bint = &amp;aint   // 初始化</span></span><br></pre></td></tr></table></figure>
<p>Go 拥有指针。指针保存了值的内存地址。</p>
<p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。其零值为 <code>nil</code>。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> p *<span class="built_in">int</span></span><br></pre></td></tr></table></figure>
<p><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span>p = <span class="meta">&amp;i</span></span><br></pre></td></tr></table></figure>
<p><code>*</code> 操作符表示指针指向的底层值。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(*p) <span class="regexp">//</span> 通过指针 p 读取 i*p = <span class="number">21</span>         <span class="regexp">//</span> 通过指针 p 设置 i</span><br></pre></td></tr></table></figure>
<p>这也就是通常所说的“间接引用”或“重定向”。</p>
<p>与 C 不同，Go 没有指针运算。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	i, j := <span class="number">42</span>, <span class="number">2701</span>	p := &amp;i         <span class="comment">// 指向 i	fmt.Println(*p) // 通过指针读取 i 的值	*p = 21         // 通过指针设置 i 的值	fmt.Println(i)  // 查看 i 的值	p = &amp;j         // 指向 j	*p = *p / 37   // 通过指针对 j 进行除法运算	fmt.Println(p)	fmt.Println(j) // 查看 j 的值&#125;</span></span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42210</span>xc<span class="number">00001805873</span></span><br></pre></td></tr></table></figure>
<p>⚠️p为地址值，*p为指针指向的值</p>
<h4 id="指针与切片"><a class="markdownIt-Anchor" href="#指针与切片"></a> 指针与切片</h4>
<p>切片与指针一样，都是引用类型。</p>
<p>如果我们想通过一个函数改变一个数组的值，有两种方法</p>
<ol>
<li>将这个数组的切片做为参数传给函数</li>
<li>将这个数组的指针做为参数传给函数</li>
</ol>
<p>尽管二者都可以实现我们的目的，但是按照 Go 语言的使用习惯，建议使用第一种方法，因为第一种方法，写出来的代码会更加简洁，易读。具体你可以参数下面两种方法的代码实现</p>
<p><strong>使用切片</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(sls []<span class="keyword">int</span>)</span></span> &#123;    sls[<span class="number">0</span>] = <span class="number">90</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;    modify(a[:])    fmt.Println(a)&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用指针</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr *[3]<span class="keyword">int</span>)</span></span> &#123;    (*arr)[<span class="number">0</span>] = <span class="number">90</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;    modify(&amp;a)    fmt.Println(a)&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h2>
<p>一个结构体（<code>struct</code>）就是一组字段（field）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;	X <span class="keyword">int</span>	Y <span class="keyword">int</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	fmt.Println(Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体字段"><a class="markdownIt-Anchor" href="#结构体字段"></a> 结构体字段</h3>
<p>结构体字段使用点号来访问。</p>
<h3 id="结构体指针"><a class="markdownIt-Anchor" href="#结构体指针"></a> 结构体指针</h3>
<p>结构体字段可以通过结构体指针来访问。</p>
<p>如果我们有一个指向结构体的指针 <code>p</code>，那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。不过这么写太啰嗦了，所以语言也允许我们使用<strong>隐式间接引用</strong>，直接写 <code>p.X</code>就可以。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;	X <span class="keyword">int</span>	Y <span class="keyword">int</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;	p := &amp;v	p.X = <span class="number">1e9</span>	fmt.Println(v)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体文法"><a class="markdownIt-Anchor" href="#结构体文法"></a> 结构体文法</h3>
<p>结构体文法通过直接列出字段的值来新分配一个结构体。</p>
<p>使用 <code>Name:</code> 语法可以仅列出部分字段。（字段名的顺序无关。）</p>
<p>特殊的前缀 <code>&amp;</code> 返回一个指向结构体的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;	X, Y <span class="keyword">int</span>&#125;<span class="keyword">var</span> (	v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// 创建一个 Vertex 类型的结构体	v2 = Vertex&#123;X: 1&#125;  // Y:0 被隐式地赋予	v3 = Vertex&#123;&#125;      // X:0 Y:0	p  = &amp;Vertex&#123;1, 2&#125; // 创建一个 *Vertex 类型的结构体（指针）)func main() &#123;	fmt.Println(v1, p, v2, v3)&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="结构体tag用法"><a class="markdownIt-Anchor" href="#结构体tag用法"></a> 结构体Tag用法</h3>
<p>字段上还可以额外再加一个属性，用反引号（Esc键下面的那个键）包含的字符串，称之为 Tag，也就是标签。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;    Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span>    Age  <span class="keyword">int</span>    <span class="string">`json:&quot;age&quot;`</span>    Addr <span class="keyword">string</span> <span class="string">`json:&quot;addr,omitempty&quot;`</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (    <span class="string">&quot;encoding/json&quot;</span>    <span class="string">&quot;fmt&quot;</span>)<span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;    Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span>    Age  <span class="keyword">int</span>    <span class="string">`json:&quot;age&quot;`</span>    Addr <span class="keyword">string</span> <span class="string">`json:&quot;addr,omitempty&quot;`</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    p1 := Person&#123;        Name: <span class="string">&quot;Jack&quot;</span>,        Age:  <span class="number">22</span>,    &#125;    data1, err := json.Marshal(p1)    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;        <span class="built_in">panic</span>(err)    &#125;    <span class="comment">// p1 没有 Addr，就不会打印了    fmt.Printf(&quot;%s\n&quot;, data1)    // ================    p2 := Person&#123;        Name: &quot;Jack&quot;,        Age:  22,        Addr: &quot;China&quot;,    &#125;    data2, err := json.Marshal(p2)    if err != nil &#123;        panic(err)    &#125;    // p2 则会打印所有    fmt.Printf(&quot;%s\n&quot;, data2)&#125;</span></span><br></pre></td></tr></table></figure>
<p>由于 Person 结构体里的 Addr 字段有 omitempty 属性，因此 encoding/json 在将对象转化 json 字符串时，只要发现对象里的 Addr 为 false， 0， 空指针，空接口，空数组，空切片，空映射，空字符串中的一种，就会被忽略。</p>
<p>因此运行后，输出的结果如下</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">go</span> run <span class="built_in">demo</span>.<span class="built_in">go</span>&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Jack&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">22</span>&#125;&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Jack&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">22</span>,<span class="string">&quot;addr&quot;</span>:<span class="string">&quot;China&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何定义获取-tag"><a class="markdownIt-Anchor" href="#如何定义获取-tag"></a> 如何定义获取 Tag ？</h3>
<p>Tag 由反引号包含，由一对或几对的键值对组成，通过空格来分割键值。格式如下</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="attr">key01:</span><span class="string">&quot;value01&quot;</span> <span class="attr">key02:</span><span class="string">&quot;value02&quot;</span> <span class="attr">key03:</span><span class="string">&quot;value03&quot;</span>`</span><br></pre></td></tr></table></figure>
<p>定义完后，如何从结构体中，取出 Tag 呢？</p>
<p>答案就是，我们上一节学过的 “反射”。</p>
<p>获取 Tag 可以分为三个步骤：</p>
<ol>
<li>获取字段 field</li>
<li>获取标签 tag</li>
<li>获取键值对 key:value</li>
</ol>
<p>演示如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三种获取 fieldfield := reflect.TypeOf(obj).FieldByName(&quot;Name&quot;)field := reflect.ValueOf(obj).Type().Field(i)  // i 表示第几个字段field := reflect.ValueOf(&amp;obj).Elem().Type().Field(i)  // i 表示第几个字段// 获取 Tagtag := field.Tag// 获取键值对labelValue := tag.Get(&quot;label&quot;)labelValue,ok := tag.Lookup(&quot;label&quot;)</span></span><br></pre></td></tr></table></figure>
<p>获取键值对，有Get 和 Lookup 两种方法，但其实 Get 只是对 Lookup 函数的简单封装而已，当没有获取到对应 tag 的内容，会返回空字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tag StructTag)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;    v, _ := tag.Lookup(key)    <span class="keyword">return</span> v&#125;</span><br></pre></td></tr></table></figure>
<p>空 Tag 和不设置 Tag 效果是一样的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (    <span class="string">&quot;fmt&quot;</span>    <span class="string">&quot;reflect&quot;</span>)<span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;    Name <span class="keyword">string</span> <span class="string">``</span>    Age <span class="keyword">string</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    p := reflect.TypeOf(Person&#123;&#125;)    name, _ := p.FieldByName(<span class="string">&quot;Name&quot;</span>)    fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, name.Tag) <span class="comment">//输出 &quot;&quot;    age, _ := p.FieldByName(&quot;Age&quot;)    fmt.Printf(&quot;%q\n&quot;, age.Tag) // 输出 &quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p>
<p>表达式</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> a [<span class="number">10</span>]<span class="built_in">int</span></span><br></pre></td></tr></table></figure>
<p>会将变量 <code>a</code> 声明为拥有 10 个整数的数组。</p>
<p>数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	<span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span>	a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span>	a[<span class="number">1</span>] = <span class="string">&quot;World&quot;</span>	fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])	fmt.Println(a)	primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;	fmt.Println(primes)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="声明方式"><a class="markdownIt-Anchor" href="#声明方式"></a> 声明方式</h3>
<ol>
<li>声明数组，并给该数组里的每个元素赋值（索引值的最小有效值和其他大多数语言一样是 0，不是1）</li>
</ol>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// <span class="comment">[3]</span> 里的3 表示该数组的元素个数及容量var arr <span class="comment">[3]</span>intarr<span class="comment">[0]</span> = 1arr<span class="comment">[1]</span> = 2arr<span class="comment">[2]</span> = 3</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>声明并直接初始化数组</li>
</ol>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 第一种方法var arr [<span class="number">3</span>]int = [<span class="number">3</span>]int&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="regexp">//</span> 第二种方法arr := [<span class="number">3</span>]int&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 3 表示数组的元素个数 ，万一你哪天想往该数组中增加元素，你得对应修改这个数字，为了避免这种硬编码，你可以这样写，使用 <code>...</code> 让Go语言自己根据实际情况来分配空间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️<code>[3]int</code> 和 <code>[4]int</code> 虽然都是数组，但他们却是不同的类型。</p>
<ol start="3">
<li>定义数组还有一种偷懒的方法，比如下面这行代码</li>
</ol>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">arr</span>:=[<span class="number">4</span>]int&#123;<span class="number">2</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>打印 arr，会是</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>可以看出<code>[4]int&#123;2:3&#125;</code>，4表示数组有4个元素，2 和 3 分别表示该数组索引为2（初始索引为0）的值为3，而其他没有指定值的，就是 int 类型的零值，即0。</p>
<h2 id="切片"><a class="markdownIt-Anchor" href="#切片"></a> 切片</h2>
<p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p>
<p>切片是对数组的一个连续片段的引用，所以切片是一个引用类型，这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集，需要注意的是，终止索引标识的项不包括在切片内（意思是这是个左闭右开的区间）。</p>
<p>类型 <code>[]T</code> 表示一个元素类型为 <code>T</code> 的切片。</p>
<p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low : <span class="type">high</span>]</span><br></pre></td></tr></table></figure>
<p>它会选择一个半开区间，包括第一个元素，但排除最后一个元素。</p>
<p>以下表达式创建了一个切片，它包含 <code>a</code>中下标从 1 到 3 的元素：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span>[<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (    <span class="string">&quot;fmt&quot;</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    myarr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;    fmt.Printf(<span class="string">&quot;%d 的类型是: %T&quot;</span>, myarr[<span class="number">0</span>:<span class="number">2</span>], myarr[<span class="number">0</span>:<span class="number">2</span>])&#125;</span><br></pre></td></tr></table></figure>
<p>输出 如下</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[1 2]</span> 的类型是: []<span class="built_in">int</span></span><br></pre></td></tr></table></figure>
<p>⚠️切片和数组是不同的类型吗，切片是[]T，数组是[n]T</p>
<h3 id="切片构造方法"><a class="markdownIt-Anchor" href="#切片构造方法"></a> 切片构造方法</h3>
<p>切片的构造，有四种方式</p>
<ol>
<li>
<p>对数组进行片段截取，主要有如下两种写法</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 定义一个数组myarr := [<span class="number">5</span>]int&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="regexp">//</span> 【第一种】<span class="regexp">//</span> <span class="number">1</span> 表示从索引<span class="number">1</span>开始，直到到索引为 <span class="number">2</span> (<span class="number">3</span>-<span class="number">1</span>)的元素mysli1 := myarr[<span class="number">1</span>:<span class="number">3</span>]<span class="regexp">//</span> 【第二种】<span class="regexp">//</span> <span class="number">1</span> 表示从索引<span class="number">1</span>开始，直到到索引为 <span class="number">2</span> (<span class="number">3</span>-<span class="number">1</span>)的元素mysli2 := myarr[<span class="number">1</span>:<span class="number">3</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>如果你把上面的 <code>mysli1</code> 和 <code>mysli2</code> 打印出来，会发现他们居然是一样的。那第二种的 <code>myarr[1:3:4]</code> 的 4有什么用呢？</p>
<p>在切片时，若不指定第三个数，那么切片终止索引会一直到原数组的最后一个数。而如果指定了第三个数，那么切片终止索引只会到原数组的该索引值。</p>
<p>用下面这段代码来验证一下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;    myarr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;    fmt.Printf(<span class="string">&quot;myarr 的长度为：%d，容量为：%d\n&quot;</span>, <span class="built_in">len</span>(myarr), <span class="built_in">cap</span>(myarr))    mysli1 := myarr[<span class="number">1</span>:<span class="number">3</span>]    fmt.Printf(<span class="string">&quot;mysli1 的长度为：%d，容量为：%d\n&quot;</span>, <span class="built_in">len</span>(mysli1), <span class="built_in">cap</span>(mysli1))    fmt.Println(mysli1)    mysli2 := myarr[<span class="number">1</span>:<span class="number">3</span>:<span class="number">4</span>]    fmt.Printf(<span class="string">&quot;mysli2 的长度为：%d，容量为：%d\n&quot;</span>, <span class="built_in">len</span>(mysli2), <span class="built_in">cap</span>(mysli2))    fmt.Println(mysli2)&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下，说明<strong>切片的第三个数，影响的只是切片的容量，而不会影响长度</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">myarr</span> 的长度为：<span class="number">5</span>，容量为：<span class="number">5</span>mysli<span class="number">1</span> 的长度为：<span class="number">2</span>，容量为：<span class="number">4</span>[<span class="number">2</span> <span class="number">3</span>]mysli<span class="number">2</span> 的长度为：<span class="number">2</span>，容量为：<span class="number">3</span>[<span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从头声明赋值（例子如下）</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 声明字符串切片var strList []string<span class="regexp">//</span> 声明整型切片var numList []int<span class="regexp">//</span> 声明一个空切片var numListEmpty = []int&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 make 函数构造，make 函数的格式：<code>make( []Type, size, cap )</code></p>
<p>这个函数刚好指出了，一个切片具备的三个要素：类型（Type），长度（size），容量（cap）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">import</span> ( &quot;<span class="selector-tag">fmt</span>&quot;)<span class="selector-tag">func</span> <span class="selector-tag">main</span>() &#123; <span class="attribute">a </span>:= <span class="built_in">make</span>([]int, <span class="number">2</span>) b := <span class="built_in">make</span>([]int, <span class="number">2</span>, <span class="number">10</span>) fmt.<span class="built_in">Println</span>(a, b) fmt.<span class="built_in">Println</span>(len(a), <span class="built_in">len</span>(b)) fmt.<span class="built_in">Println</span>(cap(a), <span class="built_in">cap</span>(b))&#125;</span><br></pre></td></tr></table></figure>
<p>输出 如下</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span>] [<span class="number">0</span> <span class="number">0</span>]<span class="number">2</span> <span class="number">22</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用和数组一样，偷懒的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ( <span class="string">&quot;fmt&quot;</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    a := []<span class="keyword">int</span>&#123;<span class="number">4</span>:<span class="number">2</span>&#125;    fmt.Println(a)    fmt.Println(<span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span>]<span class="number">5</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数组和切片异同"><a class="markdownIt-Anchor" href="#数组和切片异同"></a> 数组和切片异同</h3>
<p>数组 与 切片 有相同点，它们都是可以容纳若干类型相同的元素的容器</p>
<p>也有不同点，数组的容器大小固定，而切片本身是引用类型，它更像是 Python 中的 list ，我们可以对它 append 进行元素的添加。</p>
<h3 id="切片文法"><a class="markdownIt-Anchor" href="#切片文法"></a> 切片文法</h3>
<p>切片文法类似于没有长度的数组文法。</p>
<p>这是一个数组文法：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[3]</span><span class="built_in">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>
<p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[]</span><span class="built_in">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片的默认行为"><a class="markdownIt-Anchor" href="#切片的默认行为"></a> 切片的默认行为</h3>
<p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p>
<p>切片下界的默认值为 <code>0</code>，<strong>上界则是该切片的长度</strong>。⚠️</p>
<p>对于数组</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> a [<span class="number">10</span>]<span class="built_in">int</span></span><br></pre></td></tr></table></figure>
<p>来说，以下切片是等价的：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span>[<span class="number">0</span>:<span class="number">10</span>]a[:<span class="number">10</span>]a[<span class="number">0</span>:]a[:]</span><br></pre></td></tr></table></figure>
<h3 id="切片的长度与容量"><a class="markdownIt-Anchor" href="#切片的长度与容量"></a> 切片的长度与容量</h3>
<p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p>
<p>切片的长度就是它所包含的元素个数。</p>
<p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p>
<p>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;	printSlice(s)	<span class="comment">// 截取切片使其长度为 0	s = s[:0]	printSlice(s)	// 拓展其长度	s = s[:4]	printSlice(s)	// 舍弃前两个值	s = s[2:]	printSlice(s)&#125;func printSlice(s []int) &#123;	fmt.Printf(&quot;len=%d cap=%d %v\n&quot;, len(s), cap(s), s)&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="nil-切片"><a class="markdownIt-Anchor" href="#nil-切片"></a> nil 切片</h3>
<p>切片的零值是 <code>nil</code>。</p>
<p>nil 切片的长度和容量为 0 且没有底层数组。</p>
<h3 id="用-make-创建切片"><a class="markdownIt-Anchor" href="#用-make-创建切片"></a> 用 make 创建切片</h3>
<p>切片可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p>
<p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)  <span class="comment">// len(a)=5</span></span><br></pre></td></tr></table></figure>
<p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">b</span> := make([]int, <span class="number">0</span>, <span class="number">5</span>) // len(b)=<span class="number">0</span>, cap(b)=<span class="number">5</span>b = b[:cap(b)] // len(b)=<span class="number">5</span>, cap(b)=<span class="number">5</span>b = b[<span class="number">1</span>:]      // len(b)=<span class="number">4</span>, cap(b)=<span class="number">4</span>  </span><br></pre></td></tr></table></figure>
<p>⚠️本文内容最难理解的是切片的容量，我们可以把容量当做成<strong>总长度减去左指针走过的元素值</strong></p>
<h3 id="切片的切片"><a class="markdownIt-Anchor" href="#切片的切片"></a> 切片的切片</h3>
<p>切片可包含任何类型，甚至包括其它的切片。</p>
<h3 id="向切片追加元素"><a class="markdownIt-Anchor" href="#向切片追加元素"></a> 向切片追加元素</h3>
<p>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 <code>append</code> 函数。内建函数的<a target="_blank" rel="noopener" href="https://go-zh.org/pkg/builtin/#append">文档</a>对此函数有详细的介绍。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">append</span>(<span class="selector-tag">s</span> <span class="selector-attr">[]</span><span class="selector-tag">T</span>, <span class="selector-tag">vs</span> ..<span class="selector-class">.T</span>) <span class="selector-attr">[]</span><span class="selector-tag">T</span></span><br></pre></td></tr></table></figure>
<p><code>append</code> 的第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该切片的末尾。</p>
<p><code>append</code> 的结果是一个包含原切片所有元素加上新添加元素的切片。</p>
<p>当 <code>s</code> 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</p>
<p><img src="https://i.loli.net/2021/07/05/MFPQvwDqjT3Z1uh.png" alt="image-20210705163419742" /></p>
<p><strong>整体过程说明</strong>：</p>
<ol>
<li>创建numbers时，由于里面没有加入任何元素，所以len=0 cap=0 slice=[]</li>
<li>append(numbers, 0)时，向空切片numbers中追加了一个元素，所以len=1 cap=1 slice=[0]</li>
<li>append(numbers, 1)时，向之前的切片numbers中追加了一个元素，按<strong>Slice扩容机制</strong>，cap翻倍后=2，所以len=2 cap=2 slice=[0 1]</li>
<li>append(numbers, 2,3,4,)时，向之前的切片numbers中追加了三个元素，按Slice扩容机制，cap翻倍后2*3=6，所以len=5 cap=6 slice=[0 1 2 3 4]</li>
<li>append(numbers, 5,6,7,8,9,10)时，向之前的切片numbers中追加了六个元素，按Slice扩容机制，cap翻倍后6*2=12，所以len=11 cap=12 slice=[0 1 2 3 4 5 6 7 8 9 10]</li>
<li>新建切片numbers2 := append(numbers,11)时，是像之前的切片numbers追加一个元素11，追加后长度为12，容量为12，所以不需要扩容，len=12 cap=12 slice=[0 1 2 3 4 5 6 7 8 9 10 11]</li>
<li>新建切片numbers3 := append(numbers,12)时，是像之前的切片numbers追加一个元素12，追加后长度为12，容量为12，所以不需要扩容，len=12 cap=12 slice=[0 1 2 3 4 5 6 7 8 9 10 12]</li>
<li>创建切片numbers1时，由于cap(numbers)*2，所以容量要翻倍，len=11 cap=24 slice=[0 1 2 3 4 5 6 7 8 9 10]</li>
</ol>
<p>⚠️容量随着底层数组长度的变化而不断变化，如果底层数组长度为4，在添加了一个元素后变成5，则容量变为 4 * 2 =8，如果len=12，cap=12，如果追加一个元素后，那么新的cap=2 * 7=14。</p>
<p><strong>向切片新增一个元素时，若该切片容量已满，会首先根据切片容量进行判断，小于1024字节扩容为原有容量的2倍，大于1024字节扩容为原有容量的1.25倍</strong></p>
<h2 id="range"><a class="markdownIt-Anchor" href="#range"></a> Range</h2>
<p><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射。</p>
<p>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	<span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;		fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>可以将下标或值赋予 <code>_</code> 来忽略它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> powfor _, value := <span class="keyword">range</span> pow</span><br></pre></td></tr></table></figure>
<p>若你只需要索引，忽略第二个变量即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	pow := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)	<span class="keyword">for</span> i := <span class="keyword">range</span> pow &#123;		pow[i] = <span class="number">1</span> &lt;&lt; <span class="keyword">uint</span>(i) <span class="comment">// == 2**i	&#125;	for _, value := range pow &#123;		fmt.Printf(&quot;%d\n&quot;, value)	&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="映射字典"><a class="markdownIt-Anchor" href="#映射字典"></a> 映射/字典</h2>
<h3 id="声明方式-2"><a class="markdownIt-Anchor" href="#声明方式-2"></a> 声明方式</h3>
<p>三种声明并初始化字典的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方法var scores map[string]int = map[string]int&#123;&quot;english&quot;: 80, &quot;chinese&quot;: 85&#125;// 第二种方法scores := map[string]int&#123;&quot;english&quot;: 80, &quot;chinese&quot;: 85&#125;// 第三种方法scores := make(map[string]int)scores[&quot;english&quot;] = 80scores[&quot;chinese&quot;] = 85</span></span><br></pre></td></tr></table></figure>
<p>映射将键映射到值。</p>
<p>映射的零值为 <code>nil</code> 。<code>nil</code> 映射既没有键，也不能添加键。</p>
<p><code>make</code> 函数会返回给定类型的映射，并将其初始化备用。</p>
<h3 id="映射的文法"><a class="markdownIt-Anchor" href="#映射的文法"></a> 映射的文法</h3>
<p>映射的文法与结构体相似，不过必须有键名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;	Lat, Long <span class="keyword">float64</span>&#125;<span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;	<span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;		<span class="number">40.68433</span>, <span class="number">-74.39967</span>,	&#125;,	<span class="string">&quot;Google&quot;</span>: Vertex&#123;		<span class="number">37.42202</span>, <span class="number">-122.08408</span>,	&#125;,&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	fmt.Println(m)&#125;</span><br></pre></td></tr></table></figure>
<p>若顶级类型只是一个类型名，你可以在文法的元素中省略它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;	Lat, Long <span class="keyword">float64</span>&#125;<span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;	<span class="string">&quot;Bell Labs&quot;</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,	<span class="string">&quot;Google&quot;</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	fmt.Println(m)&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改映射"><a class="markdownIt-Anchor" href="#修改映射"></a> 修改映射</h3>
<p>在映射 <code>m</code> 中插入或修改元素：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m[<span class="built_in">key</span>] = <span class="built_in">elem</span></span><br></pre></td></tr></table></figure>
<p>获取元素：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">elem</span> = m[key]</span><br></pre></td></tr></table></figure>
<p>删除元素：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>(m, <span class="built_in">key</span>)</span><br></pre></td></tr></table></figure>
<p>通过双赋值检测某个键是否存在：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">elem</span>, ok = m[<span class="built_in">key</span>]</span><br></pre></td></tr></table></figure>
<p>若 <code>key</code> 在 <code>m</code> 中，<code>ok</code> 为 <code>true</code> ；否则，<code>ok</code> 为 <code>false</code>。</p>
<p>若 <code>key</code> 不在映射中，那么 <code>elem</code> 是该映射元素类型的零值。</p>
<p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</p>
<p><strong>注</strong> ：若 <code>elem</code> 或 <code>ok</code> 还未声明，你可以使用短变量声明：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">elem</span>, ok := m[<span class="built_in">key</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)	m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">42</span>	fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])	m[<span class="string">&quot;Answer&quot;</span>] = <span class="number">48</span>	fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])	<span class="built_in">delete</span>(m, <span class="string">&quot;Answer&quot;</span>)	fmt.Println(<span class="string">&quot;The value:&quot;</span>, m[<span class="string">&quot;Answer&quot;</span>])	v, ok := m[<span class="string">&quot;Answer&quot;</span>]	fmt.Println(<span class="string">&quot;The value:&quot;</span>, v, <span class="string">&quot;Present?&quot;</span>, ok)&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数的闭包"><a class="markdownIt-Anchor" href="#函数的闭包"></a> 函数的闭包</h2>
<p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;	sum := <span class="number">0</span>	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;		sum += x		<span class="keyword">return</span> sum	&#125;&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	pos, neg := adder(), adder()	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;		fmt.Println(			pos(i),			neg(<span class="number">-2</span>*i),		)	&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="斐波纳契闭包"><a class="markdownIt-Anchor" href="#斐波纳契闭包"></a> 斐波纳契闭包</h3>
<p>实现一个 <code>fibonacci</code> 函数，它返回一个函数（闭包），该闭包返回一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">斐波纳契数列</a> <code>(0, 1, 1, 2, 3, 5, ...)</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="comment">// 返回一个“返回int的函数”func fibonacci() func() int &#123;	back1, back2:= 0,1 	return func() int&#123;		temp := back1 //记录（back1）的值          back1,back2 = back2,(back1 + back2) // 重新赋值(这个就是核心代码)            return temp //返回temp	&#125;		&#125;func main() &#123;	f := fibonacci()	for i := 0; i &lt; 10; i++ &#123;		fmt.Println(f())	&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="函数与接口"><a class="markdownIt-Anchor" href="#函数与接口"></a> 函数与接口</h2>
<h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3>
<p>Go 没有类。不过你可以为结构体类型定义方法。</p>
<h4 id="结构体-2"><a class="markdownIt-Anchor" href="#结构体-2"></a> 结构体</h4>
<p>方法就是一类带特殊的 <strong>接收者</strong> 参数的函数。</p>
<p>方法接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p>
<p>在此例中，<code>Abs</code> 方法拥有一个名为 <code>v</code>，类型为 <code>Vertex</code> 的接收者。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (	<span class="string">&quot;fmt&quot;</span>	<span class="string">&quot;math&quot;</span>)<span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;	X, Y <span class="keyword">float64</span>&#125;<span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123; <span class="comment">//带接收者的写法	return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123;	v := Vertex&#123;3, 4&#125;	fmt.Println(v.Abs())  //设定接收者&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>方法即函数</strong></p>
<p>记住：<strong>方法只是个带接收者参数的函数。</strong></p>
<p>现在这个 <code>Abs</code> 的写法就是个正常的函数，功能并没有什么变化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span> <span class="title">float64</span></span> &#123;  <span class="comment">//不带接收者的写法	return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="非结构体"><a class="markdownIt-Anchor" href="#非结构体"></a> 非结构体</h4>
<p>你也可以为<strong>非结构体类型</strong>声明方法。</p>
<p>在此例中，我们看到了一个带 <code>Abs</code> 方法的数值类型 <code>MyFloat</code>。</p>
<p>你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 <code>int</code> 之类的内建类型）的接收者声明方法。</p>
<p>（译注：就是<strong>接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法</strong>。）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (	<span class="string">&quot;fmt&quot;</span>	<span class="string">&quot;math&quot;</span>)<span class="keyword">type</span> MyFloat float64func (f MyFloat) Abs() <span class="keyword">float64</span> &#123;	<span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;		<span class="keyword">return</span> <span class="keyword">float64</span>(-f)	&#125;	<span class="keyword">return</span> <span class="keyword">float64</span>(f)&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	f := MyFloat(-math.Sqrt2)	fmt.Println(f.Abs())&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指针-2"><a class="markdownIt-Anchor" href="#指针-2"></a> 指针</h4>
<p>可以为<strong>指针接收者</strong>声明方法。</p>
<p>这意味着对于某类型 <code>T</code>，接收者的类型可以用 <code>*T</code> 的文法。（此外，<code>T</code> 不能是像 <code>*int</code> 这样的指针。）</p>
<p>例如，这里为 <code>*Vertex</code> 定义了 <code>Scale</code> 方法。</p>
<p>指针接收者的方法可以修改接收者指向的值（就像 <code>Scale</code> 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。</p>
<p>若使用值接收者，那么 <code>Scale</code> 方法会对原始 <code>Vertex</code> 值的副本进行操作。（对于函数的其它参数也是如此。）<code>Scale</code> 方法必须用指针接受者来更改 <code>main</code> 函数中声明的 <code>Vertex</code> 的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (	<span class="string">&quot;fmt&quot;</span>	<span class="string">&quot;math&quot;</span>)<span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;	X, Y <span class="keyword">float64</span>&#125;<span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;<span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;	v.X = v.X * f	v.Y = v.Y * f&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;	v.Scale(<span class="number">10</span>)	fmt.Println(v.Abs())&#125;</span><br></pre></td></tr></table></figure>
<p>带指针参数的函数必须接受一个指针：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var v VertexScaleFunc(v, <span class="number">5</span>)  <span class="regexp">//</span> 编译错误！ScaleFunc(&amp;v, <span class="number">5</span>) <span class="regexp">//</span> OK</span><br></pre></td></tr></table></figure>
<p>而以指针为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var v Vertexv.Scale(<span class="number">5</span>)  <span class="regexp">//</span> OKp := &amp;vp.Scale(<span class="number">10</span>) <span class="regexp">//</span> OK</span><br></pre></td></tr></table></figure>
<p>对于语句 <code>v.Scale(5)</code>，即便 <code>v</code> 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code> 方法有一个指针接收者，为方便起见，<strong>Go 会将语句 <code>v.Scale(5)</code> 解释为 <code>(&amp;v).Scale(5)</code>。</strong></p>
<p>接受一个值作为参数的函数必须接受一个指定类型的值：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var v Vertexfmt.Println(AbsFunc(v))  <span class="regexp">//</span> OKfmt.Println(AbsFunc(&amp;v)) <span class="regexp">//</span> 编译错误！</span><br></pre></td></tr></table></figure>
<p>而以值为接收者的方法被调用时，接收者既能为值又能为指针：</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var v Vertexfmt.Print<span class="meta">ln(</span>v<span class="meta">.Abs(</span>)) // OKp := <span class="variable">&amp;vfmt.</span>Print<span class="meta">ln(</span>p<span class="meta">.Abs(</span>)) // OK</span><br></pre></td></tr></table></figure>
<p>这种情况下，<strong>方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code>。</strong></p>
<h4 id="选择值或指针作为接收者"><a class="markdownIt-Anchor" href="#选择值或指针作为接收者"></a> 选择值或指针作为接收者</h4>
<p>使用指针接收者的原因有二：</p>
<p>首先，方法能够修改其接收者指向的值。</p>
<p>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (	<span class="string">&quot;fmt&quot;</span>	<span class="string">&quot;math&quot;</span>)<span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;	X, Y <span class="keyword">float64</span>&#125;<span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;	v.X = v.X * f	v.Y = v.Y * f&#125;<span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;	fmt.Printf(<span class="string">&quot;Before scaling: %+v, Abs: %v\n&quot;</span>, v, v.Abs())	v.Scale(<span class="number">5</span>)	fmt.Printf(<span class="string">&quot;After scaling: %+v, Abs: %v\n&quot;</span>, v, v.Abs())&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3>
<p><strong>接口类型</strong> 是由一组方法签名定义的集合。</p>
<p>接口类型的变量可以保存任何实现了这些方法的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (	<span class="string">&quot;fmt&quot;</span>	<span class="string">&quot;math&quot;</span>)<span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;	Abs() <span class="keyword">float64</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	<span class="keyword">var</span> a Abser	f := MyFloat(-math.Sqrt2)	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;	a = f  <span class="comment">// a MyFloat 实现了 Abser	a = &amp;v // a *Vertex 实现了 Abser	// 下面一行，v 是一个 Vertex（而不是 *Vertex）	// 所以没有实现 Abser。	a = &amp;v	fmt.Println(a.Abs())&#125;type MyFloat float64func (f MyFloat) Abs() float64 &#123;	if f &lt; 0 &#123;		return float64(-f)	&#125;	return float64(f)&#125;type Vertex struct &#123;	X, Y float64&#125;func (v *Vertex) Abs() float64 &#123;	return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;</span></span><br></pre></td></tr></table></figure>
<p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p>
<p>隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p>
<p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;	M()&#125;<span class="keyword">type</span> T <span class="keyword">struct</span> &#123;	S <span class="keyword">string</span>&#125;<span class="comment">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。func (t T) M() &#123; //此处即为实现M方法	fmt.Println(t.S)&#125;func main() &#123;	var i I = T&#123;&quot;hello&quot;&#125;	i.M()&#125;</span></span><br></pre></td></tr></table></figure>
<p>接口也是值。它们可以像其它值一样传递。</p>
<p>接口值可以用作函数的参数或返回值。</p>
<p>在内部，接口值可以看做包含值和具体类型的元组：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(value, <span class="keyword">type</span>)</span><br></pre></td></tr></table></figure>
<p>接口值保存了一个具体底层类型的具体值。</p>
<p>接口值调用方法时会执行其底层类型的同名方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (	<span class="string">&quot;fmt&quot;</span>	<span class="string">&quot;math&quot;</span>)<span class="keyword">type</span> I <span class="keyword">interface</span> &#123;	M()&#125;<span class="keyword">type</span> T <span class="keyword">struct</span> &#123;	S <span class="keyword">string</span>&#125;<span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;	fmt.Println(t.S)&#125;<span class="keyword">type</span> F float64func (f F) M() &#123;	fmt.Println(f)&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	<span class="keyword">var</span> i I	i = &amp;T&#123;<span class="string">&quot;Hello&quot;</span>&#125;	describe(i)	i.M()	i = F(math.Pi)	describe(i)	i.M()&#125;<span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;	fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)&#125;</span><br></pre></td></tr></table></figure>
<h4 id="底层值为-nil-的接口值"><a class="markdownIt-Anchor" href="#底层值为-nil-的接口值"></a> 底层值为 nil 的接口值</h4>
<p>即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。</p>
<p>在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 <code>M</code> 方法）。</p>
<p><strong>注意:</strong> 保存了 nil 具体值的接口其自身并不为 nil。</p>
<h4 id="nil-接口值"><a class="markdownIt-Anchor" href="#nil-接口值"></a> nil 接口值</h4>
<p>nil 接口值既不保存值也不保存具体类型。</p>
<p>为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 <strong>具体</strong> 方法的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i Ivar t *Ti = t   <span class="comment">//底层值是nildescribe(i)i.M()var i I  //接口值是nil  ----&gt; runtime error: invalid memory address or nil pointer dereferencedescribe(i)i.M()</span></span><br></pre></td></tr></table></figure>
<h4 id="空接口"><a class="markdownIt-Anchor" href="#空接口"></a> 空接口</h4>
<p>指定了零个方法的接口值被称为 <em>空接口：</em></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p>
<p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface&#123;&#125;</code>的任意数量的参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;	describe(i)	i = <span class="number">42</span>	describe(i)	i = <span class="string">&quot;hello&quot;</span>	describe(i)&#125;<span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;	fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️1. 空接口可以承载任意值，但不代表任意类型就可以承接空接口类型的值</p>
<ol start="2">
<li>当空接口承载数组和切片后，该对象无法再进行切片</li>
<li>当你使用空接口来接收任意类型的参数时，它的静态类型是 interface{}，但动态类型（是 int，string 还是其他类型）我们并不知道，因此需要使用类型断言。</li>
</ol>
<h4 id="类型断言"><a class="markdownIt-Anchor" href="#类型断言"></a> 类型断言</h4>
<p><strong>类型断言</strong> 提供了访问接口值底层具体值的方式。</p>
<p>Type Assertion（中文名叫：类型断言），通过它可以做到以下几件事情</p>
<ol>
<li>检查 <code>i</code> 是否为 nil</li>
<li>检查 <code>i</code> 存储的值是否为某个类型</li>
</ol>
<p><strong>第一种：</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">t</span> <span class="symbol">:</span>= i.(<span class="built_in">T</span>)</span><br></pre></td></tr></table></figure>
<p>这个表达式可以断言一个接口对象（i）里不是 nil，并且接口对象（i）存储的值的类型是 T，如果断言成功，就会返回值给 t，如果断言失败，就会触发 panic。</p>
<p><strong>第二种</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">t</span>, <span class="symbol">ok:</span>= i.(<span class="built_in">T</span>)</span><br></pre></td></tr></table></figure>
<p>和上面一样，这个表达式也是可以断言一个接口对象（i）里不是 nil，并且接口对象（i）存储的值的类型是 T，如果断言成功，就会返回其类型给 t，并且此时 ok 的值 为 true，表示断言成功。</p>
<p>如果接口值的类型，并不是我们所断言的 T，就会断言失败，但和第一种表达式不同的事，这个不会触发 panic，而是将 ok 的值设为 false ，表示断言失败，此时t 为 T 的零值。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">t</span> <span class="symbol">:</span>= i.(<span class="built_in">T</span>)</span><br></pre></td></tr></table></figure>
<p>该语句断言接口值 <code>i</code> 保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code> 的值赋予变量 <code>t</code>。</p>
<p>若 <code>i</code> 并未保存 <code>T</code> 类型的值，该语句就会触发一个恐慌。</p>
<p>为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">t</span>, ok <span class="symbol">:</span>= i.(<span class="built_in">T</span>)</span><br></pre></td></tr></table></figure>
<p>若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。</p>
<p>否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span>	s := i.(<span class="keyword">string</span>)	fmt.Println(s)	s, ok := i.(<span class="keyword">string</span>)	fmt.Println(s, ok)	f, ok := i.(<span class="keyword">float64</span>)	fmt.Println(f, ok)	f = i.(<span class="keyword">float64</span>) <span class="comment">// 报错(panic)	fmt.Println(f)&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="类型选择"><a class="markdownIt-Anchor" href="#类型选择"></a> 类型选择</h4>
<p><strong>类型选择</strong> 是一种按顺序从几个类型断言中选择分支的结构。</p>
<p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">switch</span> v := i.(<span class="keyword">type</span>) &#123;case <span class="type">T</span>:    // v 的类型为 <span class="type">Tcase</span> <span class="type">S</span>:    // v 的类型为 <span class="type">Sdefault</span>:    // 没有匹配，v 与 i 的类型相同&#125;</span><br></pre></td></tr></table></figure>
<p>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。</p>
<p>此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code>会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;	<span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;	<span class="keyword">case</span> <span class="keyword">int</span>:		fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)	<span class="keyword">case</span> <span class="keyword">string</span>:		fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))	<span class="keyword">default</span>:		fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)	&#125;&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	do(<span class="number">21</span>)	do(<span class="string">&quot;hello&quot;</span>)	do(<span class="literal">true</span>)&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在 Go 语言中，是通过接口来实现的多态。</strong></p>
<h3 id="stringer"><a class="markdownIt-Anchor" href="#stringer"></a> Stringer</h3>
<p><a target="_blank" rel="noopener" href="https://go-zh.org/pkg/fmt/"><code>fmt</code></a> 包中定义的 <a target="_blank" rel="noopener" href="https://go-zh.org/pkg/fmt/#Stringer"><code>Stringer</code></a> 是最普遍的接口之一。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;    <span class="built_in">String</span>() <span class="built_in">string</span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;	Name <span class="keyword">string</span>	Age  <span class="keyword">int</span>&#125;<span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;	z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;	fmt.Println(a, z)&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误"><a class="markdownIt-Anchor" href="#错误"></a> 错误</h2>
<p>Go 程序使用 <code>error</code> 值来表示错误状态。</p>
<p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="builtin-name">error</span><span class="built_in"> interface </span>&#123;    <span class="builtin-name">Error</span>() string&#125;</span><br></pre></td></tr></table></figure>
<p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包在打印值时也会满足 <code>error</code>。）</p>
<p>通常函数会返回一个 <code>error</code> 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i, <span class="keyword">err</span> := strconv.Atoi(<span class="string">&quot;42&quot;</span>)<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;    fmt.Printf(<span class="string">&quot;couldn&#x27;t convert number: %v\n&quot;</span>, <span class="keyword">err</span>)    <span class="keyword">return</span>&#125;fmt.Println(<span class="string">&quot;Converted integer:&quot;</span>, i)</span><br></pre></td></tr></table></figure>
<p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示失败。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (	<span class="string">&quot;fmt&quot;</span>	<span class="string">&quot;time&quot;</span>)<span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;	When time.Time	What <span class="keyword">string</span>&#125;<span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;at %v, %s&quot;</span>,		e.When, e.What)&#125;<span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;	<span class="keyword">return</span> &amp;MyError&#123;		time.Now(),		<span class="string">&quot;it didn&#x27;t work&quot;</span>,	&#125;&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	<span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;		fmt.Println(err)	&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="reader"><a class="markdownIt-Anchor" href="#reader"></a> Reader</h2>
<p><code>io</code> 包指定了 <code>io.Reader</code> 接口，它表示从数据流的末尾进行读取。</p>
<p>Go 标准库包含了该接口的<a target="_blank" rel="noopener" href="https://go-zh.org/search?q=Read#Global">许多实现</a>，包括文件、网络连接、压缩和加密等等。</p>
<p><code>io.Reader</code> 接口有一个 <code>Read</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p><code>Read</code> 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code> 错误。</p>
<p>示例代码创建了一个 <a target="_blank" rel="noopener" href="https://go-zh.org/pkg/strings/#Reader"><code>strings.Reader</code></a> 并以每次 8 字节的速度读取它的输出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (	<span class="string">&quot;fmt&quot;</span>	<span class="string">&quot;io&quot;</span>	<span class="string">&quot;strings&quot;</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)	<span class="keyword">for</span> &#123;		n, err := r.Read(b)		fmt.Printf(<span class="string">&quot;n = %v err = %v b = %v\n&quot;</span>, n, err, b)		fmt.Printf(<span class="string">&quot;b[:n] = %q\n&quot;</span>, b[:n])		<span class="keyword">if</span> err == io.EOF &#123;			<span class="keyword">break</span>		&#125;	&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图像"><a class="markdownIt-Anchor" href="#图像"></a> 图像</h2>
<p><a target="_blank" rel="noopener" href="https://go-zh.org/pkg/image/#Image"><code>image</code></a> 包定义了 <code>Image</code> 接口：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">package</span> image<span class="keyword">type</span> <span class="type">Image</span> interface &#123;    <span class="type">ColorModel</span>() color.<span class="type">Model</span>    <span class="type">Bounds</span>() <span class="type">Rectangle</span>    <span class="type">At</span>(x, y int) color.<span class="type">Color</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> <code>Bounds</code> 方法的返回值 <code>Rectangle</code> 实际上是一个 <a target="_blank" rel="noopener" href="https://go-zh.org/pkg/image/#Rectangle"><code>image.Rectangle</code></a>，它在 <code>image</code> 包中声明。</p>
<p>（请参阅<a target="_blank" rel="noopener" href="https://go-zh.org/pkg/image/#Image">文档</a>了解全部信息。）</p>
<p><code>color.Color</code> 和 <code>color.Model</code> 类型也是接口，但是通常因为直接使用预定义的实现 <code>image.RGBA</code> 和 <code>image.RGBAModel</code> 而被忽视了。这些接口和类型由 <a target="_blank" rel="noopener" href="https://go-zh.org/pkg/image/color/"><code>image/color</code></a> 包定义。</p>
<h2 id="异常机制panic-和-recover"><a class="markdownIt-Anchor" href="#异常机制panic-和-recover"></a> 异常机制：panic 和 recover</h2>
<h3 id="1-触发panic"><a class="markdownIt-Anchor" href="#1-触发panic"></a> 1. 触发panic</h3>
<p>手动触发宕机，是非常简单的一件事，只需要调用 panic 这个内置函数即可，就像这样子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainfunc main() &#123;    <span class="built_in">panic</span>(<span class="string">&quot;crash&quot;</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>运行后，直接报错宕机</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.gogo run main.<span class="attr">gopanic:</span> crashgoroutine <span class="number">1</span> [running]:main.main()        <span class="attr">E:</span><span class="regexp">/Go-Code/</span>main.<span class="attr">go:</span><span class="number">4</span> +<span class="number">0x40e</span>xit status <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="2-捕获-panic"><a class="markdownIt-Anchor" href="#2-捕获-panic"></a> 2. 捕获 panic</h3>
<p>内建函数 – <code>recover</code>，它可以让程序在发生宕机后起生回生。</p>
<p>但是 recover 的使用，有一个条件，就是它必须在 defer 函数中才能生效，其他作用域下，它是不工作的。</p>
<p>这是一个简单的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">set_data</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;        <span class="comment">// recover() 可以将捕获到的panic信息打印        if err := recover(); err != nil &#123;            fmt.Println(err)        &#125;    &#125;()    // 故意制造数组越界，触发 panic    var arr [10]int    arr[x] = 88&#125;func main() &#123;    set_data(20)    // 如果能执行到这句，说明panic被捕获了    // 后续的程序能继续运行    fmt.Println(&quot;everything is ok&quot;)&#125;</span></span><br></pre></td></tr></table></figure>
<p>运行后，输出如下</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">run</span> main.goruntime <span class="keyword">error</span>: index <span class="keyword">out of</span> range [<span class="number">20</span>] <span class="keyword">with</span> <span class="built_in">length</span> <span class="number">10</span>everything <span class="keyword">is</span> ok</span><br></pre></td></tr></table></figure>
<p>⚠️即使 panic 会导致整个程序退出，但在退出前，若有 defer 延迟函数，还是得执行完 defer 。但是这个 defer 在多个协程之间是没有效果，在子协程里触发 panic，只能触发自己协程内的 defer，而不能调用 main 协程里的 defer 函数的。</p>
<p>Golang 异常的抛出与捕获，依赖两个内置函数：</p>
<ul>
<li>panic：抛出异常，使程序崩溃</li>
<li>recover：捕获异常，恢复程序或做收尾工作</li>
</ul>
<p>revocer 调用后，抛出的 panic 将会在此处终结，不会再外抛，但是 recover，并不能任意使用，它有强制要求，必须得在 defer 下才能发挥用途。</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>go基础学习</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://mylovewxy.live/posts/498781b7/">https://mylovewxy.live/posts/498781b7/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a" style="display: inline-block;width: 120px"><h>作者</h><div class="post-copyright-cc-info"><h>my</h></div></div><div class="post-copyright-c" style="display: inline-block;width: 120px"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-09-02</h></div></div><div class="post-copyright-u" style="display: inline-block;width: 120px"><h>更新于</h><div class="post-copyright-cc-info"><h>2021-09-02</h></div></div><div class="post-copyright-c" style="display: inline-block;width: 120px"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY 4.0" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/go/">go</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/mywxy/image/master/PicxImage/xxx.6jdj6j8mns40.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/507aba41/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/mywxy/image@master/PicxImage/network-3537401_1920.6nzxq9tpyys0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Https原理</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/mywxy/image@master/PicxImage/avatar.mih18dfv400.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">my</div><div class="author-info__description">我与我周旋久</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mywxy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mywxy" target="_blank" title="Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="mailto:mymywxy@gmail.com" target="_blank" title="Email"><i class="iconfont icon-youxiang-mail_fill"></i></a><a class="social-icon" href="https://twitter.com/yongye13" target="_blank" title="Twitter"><i class="iconfont icon-twitter"></i></a></div></div></div><div class="card-widget card-recent-post"><div id="gamenews"><div class="card-content"><div class="item-headline"><i class="fas fa-cube"></i><span>ROLL资讯</span><i class="fas fa-retweet" @click="changetype(current)" style="float:right;margin-top:8px"></i></div><div class="newsbar"><span v-for="(type, index) in listtype" v-on:click="addClass(index)" v-bind:class="{ listtypeon:index==current}">{{type}}</span></div><div class="aside-list"><div class="aside-list-item" v-for="(news,index) in newsvue"><a class="thumbnail" href="javascript:void(0)" @click="getnewsdata(index)" :title="news.title"><img class="loaded" onerror="this.onerror=null;this.src='/img/404.jpg'" data-ll-status="loaded" :src="news.imgList[0]"/></a><div class="content"><a class="title" href="javascript:void(0)" @click="getnewsdata(index)" :title="news.title">{{news.title}}</a><time>{{news.postTime}}</time></div></div></div></div><div id="newsmodal"><button class="modalclose" @click="hidemodle()">关闭</button><h2>{{newpostvue.title}} </h2><h4>{{newpostvue.ptime}} &nbsp;&nbsp; {{newpostvue.source}}</h4><div v-html="newpostvue.content"></div></div></div></div><div class="card-widget card-pixiv"><div class="card-content"><div class="item-headline"><i class="fa fa-image" aria-hidden="true"></i><span>Pixiv日榜Top50</span><iframe src="https://cloud.mokeyjay.com/pixiv" frameborder="0" style="width:99%;height:380px;margin:0;"></iframe></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text"> go基础学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.1.</span> <span class="toc-text"> 注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0"><span class="toc-number">1.2.</span> <span class="toc-text"> 标记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.</span> <span class="toc-text"> 内置关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text"> 预定义标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text"> 包，变量，函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E5%90%8D"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 导出名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 命名返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text"> 变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.5.5.</span> <span class="toc-text"> 变量的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.6.</span> <span class="toc-text"> 基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">1.5.6.1.</span> <span class="toc-text"> 整型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.5.6.2.</span> <span class="toc-text"> 不同进制表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fmt%E5%8C%85"><span class="toc-number">1.5.6.3.</span> <span class="toc-text"> fmt包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">1.5.6.4.</span> <span class="toc-text"> 浮点数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#byte-%E4%B8%8E-rune"><span class="toc-number">1.5.6.5.</span> <span class="toc-text"> byte 与 rune</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string"><span class="toc-number">1.5.6.6.</span> <span class="toc-text"> string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.6.7.</span> <span class="toc-text"> 布尔类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E5%80%BC"><span class="toc-number">1.5.7.</span> <span class="toc-text"> 零值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.8.</span> <span class="toc-text"> 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.5.9.</span> <span class="toc-text"> 类型推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">1.5.10.</span> <span class="toc-text"> 常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%B8%B8%E9%87%8F"><span class="toc-number">1.5.11.</span> <span class="toc-text"> 数值常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.12.</span> <span class="toc-text"> 五种变量声明的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%80%E8%A1%8C%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.12.1.</span> <span class="toc-text"> 1. 一行声明一个变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E4%B8%80%E8%B5%B7%E5%A3%B0%E6%98%8E"><span class="toc-number">1.5.12.2.</span> <span class="toc-text"> 2.多个变量一起声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.12.3.</span> <span class="toc-text"> 3. 声明和初始化一个变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.12.4.</span> <span class="toc-text"> 4. 声明和初始化多个变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-new-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.12.5.</span> <span class="toc-text"> 5. new 函数声明一个指针变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.6.</span> <span class="toc-text"> 流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for"><span class="toc-number">1.6.1.</span> <span class="toc-text"> for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if"><span class="toc-number">1.6.2.</span> <span class="toc-text"> if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">1.6.3.</span> <span class="toc-text"> 练习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.3.1.</span> <span class="toc-text"> 循环与函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">1.6.4.</span> <span class="toc-text"> switch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA-case-%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.6.4.1.</span> <span class="toc-text"> 一个 case 多个条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch-%E5%90%8E%E5%8F%AF%E6%8E%A5%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.4.2.</span> <span class="toc-text"> switch 后可接函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case-%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97-fallthrough-%E5%BC%80%E5%90%AF%E7%A9%BF%E9%80%8F%E8%83%BD%E5%8A%9B"><span class="toc-number">1.6.4.3.</span> <span class="toc-text"> case 使用关键字 fallthrough 开启穿透能力</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E6%9D%A1%E4%BB%B6%E7%9A%84-switch"><span class="toc-number">1.6.5.</span> <span class="toc-text"> 没有条件的 switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-number">1.6.6.</span> <span class="toc-text"> defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goto"><span class="toc-number">1.6.7.</span> <span class="toc-text"> goto</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.7.</span> <span class="toc-text"> 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.0.1.</span> <span class="toc-text"> 创建方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%88%87%E7%89%87"><span class="toc-number">1.7.0.2.</span> <span class="toc-text"> 指针与切片</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.8.</span> <span class="toc-text"> 结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5"><span class="toc-number">1.8.1.</span> <span class="toc-text"> 结构体字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="toc-number">1.8.2.</span> <span class="toc-text"> 结构体指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%87%E6%B3%95"><span class="toc-number">1.8.3.</span> <span class="toc-text"> 结构体文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93tag%E7%94%A8%E6%B3%95"><span class="toc-number">1.8.4.</span> <span class="toc-text"> 结构体Tag用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E8%8E%B7%E5%8F%96-tag"><span class="toc-number">1.8.5.</span> <span class="toc-text"> 如何定义获取 Tag ？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.</span> <span class="toc-text"> 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F"><span class="toc-number">1.9.1.</span> <span class="toc-text"> 声明方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">1.10.</span> <span class="toc-text"> 切片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.1.</span> <span class="toc-text"> 切片构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E5%BC%82%E5%90%8C"><span class="toc-number">1.10.2.</span> <span class="toc-text"> 数组和切片异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E6%96%87%E6%B3%95"><span class="toc-number">1.10.3.</span> <span class="toc-text"> 切片文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.10.4.</span> <span class="toc-text"> 切片的默认行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%8E%E5%AE%B9%E9%87%8F"><span class="toc-number">1.10.5.</span> <span class="toc-text"> 切片的长度与容量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nil-%E5%88%87%E7%89%87"><span class="toc-number">1.10.6.</span> <span class="toc-text"> nil 切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-make-%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87"><span class="toc-number">1.10.7.</span> <span class="toc-text"> 用 make 创建切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%88%87%E7%89%87"><span class="toc-number">1.10.8.</span> <span class="toc-text"> 切片的切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E5%88%87%E7%89%87%E8%BF%BD%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">1.10.9.</span> <span class="toc-text"> 向切片追加元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#range"><span class="toc-number">1.11.</span> <span class="toc-text"> Range</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%AD%97%E5%85%B8"><span class="toc-number">1.12.</span> <span class="toc-text"> 映射&#x2F;字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F-2"><span class="toc-number">1.12.1.</span> <span class="toc-text"> 声明方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%9A%84%E6%96%87%E6%B3%95"><span class="toc-number">1.12.2.</span> <span class="toc-text"> 映射的文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%98%A0%E5%B0%84"><span class="toc-number">1.12.3.</span> <span class="toc-text"> 修改映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AD%E5%8C%85"><span class="toc-number">1.13.</span> <span class="toc-text"> 函数的闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E7%BA%B3%E5%A5%91%E9%97%AD%E5%8C%85"><span class="toc-number">1.13.1.</span> <span class="toc-text"> 斐波纳契闭包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.14.</span> <span class="toc-text"> 函数与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.14.1.</span> <span class="toc-text"> 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-2"><span class="toc-number">1.14.1.1.</span> <span class="toc-text"> 结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.14.1.2.</span> <span class="toc-text"> 非结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88-2"><span class="toc-number">1.14.1.3.</span> <span class="toc-text"> 指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%80%BC%E6%88%96%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">1.14.1.4.</span> <span class="toc-text"> 选择值或指针作为接收者</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.14.2.</span> <span class="toc-text"> 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%80%BC%E4%B8%BA-nil-%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="toc-number">1.14.2.1.</span> <span class="toc-text"> 底层值为 nil 的接口值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nil-%E6%8E%A5%E5%8F%A3%E5%80%BC"><span class="toc-number">1.14.2.2.</span> <span class="toc-text"> nil 接口值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.14.2.3.</span> <span class="toc-text"> 空接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">1.14.2.4.</span> <span class="toc-text"> 类型断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="toc-number">1.14.2.5.</span> <span class="toc-text"> 类型选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stringer"><span class="toc-number">1.14.3.</span> <span class="toc-text"> Stringer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF"><span class="toc-number">1.15.</span> <span class="toc-text"> 错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reader"><span class="toc-number">1.16.</span> <span class="toc-text"> Reader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F"><span class="toc-number">1.17.</span> <span class="toc-text"> 图像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6panic-%E5%92%8C-recover"><span class="toc-number">1.18.</span> <span class="toc-text"> 异常机制：panic 和 recover</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%A7%A6%E5%8F%91panic"><span class="toc-number">1.18.1.</span> <span class="toc-text"> 1. 触发panic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8D%95%E8%8E%B7-panic"><span class="toc-number">1.18.2.</span> <span class="toc-text"> 2. 捕获 panic</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-clock"><div id="clock"><img v-if="clockshow == &quot;false&quot;" alt="" src="/assets/weather/loading.gif" height="120px" width="100%"/><table class="clock" v-if="clockshow"><tbody><tr><td class="clockdate">{{date}}</td><td class="weatherimg"><img id="weatherimg" :src="weatherimg" alt=""/></td><td class="temperature">{{temperature}}</td><td class="humidityimg"><img id="humidityimg" :src="humidityimg" alt=""/></td><td class="humidity">{{humidity}}</td></tr><tr class="time"><td colspan="5">{{time}}</td></tr><tr><td class="usaqi" colspan="1"><span>{{ip}}</span></td><td class="city" colspan="2">{{city}}</td><td class="daylight" colspan="2">{{daylight}}</td></tr></tbody></table></div></div><script defer="defer" data-pjax="data-pjax" src="/js/card_clock.js"></script><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/498781b7/" title="go基础学习"><img src="https://raw.githubusercontent.com/mywxy/image/master/PicxImage/xxx.6jdj6j8mns40.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go基础学习"/></a><div class="content"><a class="title" href="/posts/498781b7/" title="go基础学习">go基础学习</a><time datetime="2021-09-02T03:41:19.037Z" title="发表于 2021-09-02 03:41:19">2021-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/507aba41/" title="Https原理"><img src="https://cdn.jsdelivr.net/gh/mywxy/image@master/PicxImage/network-3537401_1920.6nzxq9tpyys0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Https原理"/></a><div class="content"><a class="title" href="/posts/507aba41/" title="Https原理">Https原理</a><time datetime="2021-05-16T12:49:30.000Z" title="发表于 2021-05-16 12:49:30">2021-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/85ac9139/" title="MySQL-InnoDB-MVCC多版本并发控制"><img src="https://gitee.com/mymywxy/pic-go/raw/master/img/20201216165951.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL-InnoDB-MVCC多版本并发控制"/></a><div class="content"><a class="title" href="/posts/85ac9139/" title="MySQL-InnoDB-MVCC多版本并发控制">MySQL-InnoDB-MVCC多版本并发控制</a><time datetime="2021-04-24T15:51:54.000Z" title="发表于 2021-04-24 15:51:54">2021-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a2fdc053/" title="设计模式大总结"><img src="https://cdn.jsdelivr.net/gh/mywxy/image@master/image.2wwssgeh6m00.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式大总结"/></a><div class="content"><a class="title" href="/posts/a2fdc053/" title="设计模式大总结">设计模式大总结</a><time datetime="2021-04-02T17:47:08.000Z" title="发表于 2021-04-02 17:47:08">2021-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2eb98691/" title="数据流的中位数"><img src="https://cdn.jsdelivr.net/gh/mywxy/image@master/PicxImage/image.6z9wjjuh6bk0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据流的中位数"/></a><div class="content"><a class="title" href="/posts/2eb98691/" title="数据流的中位数">数据流的中位数</a><time datetime="2021-03-20T13:52:56.000Z" title="发表于 2021-03-20 13:52:56">2021-03-20</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://raw.githubusercontent.com/mywxy/image/master/PicxImage/xxx.6jdj6j8mns40.jpeg)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By my</div><div class="footer_custom_text"><p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://demo.jerryc.me/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://metroui.org.ua/index.html "><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script defer src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 5000);</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', '', 'katex-wrap')
  })
})()</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init({
      envId: 'my-2gdo2r5xbc8ec12c',
      el: '#twikoo-wrap'
    })
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'my-2gdo2r5xbc8ec12c',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(()=>{getCount()},0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(()=>{getCount()},0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>var gitcalendar = new Vue({
  el: '#gitcalendar',
  data: {
    simplemode: true,
    user: 'mywxy',
    fixed: 'fixed',
    px: 'px',
    x: '',
    y: '',
    span1: '',
    span2: '',
    month: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
    monthchange: [],
    oneyearbeforeday: '',
    thisday: '',
    amonthago: '',
    aweekago: '',
    weekdatacore: 0,
    datacore: 0,
    total: 0,
    datadate: '',
    data: [],
    positionplusdata: [],
    firstweek: [],
    lastweek: [],
    beforeweek: [],
    thisweekdatacore: 0,
    mounthbeforeday: 0,
    mounthfirstindex: 0,
    crispedges: 'crispedges',
    thisdayindex: 0,
    amonthagoindex: 0,
    amonthagoweek: [],
    firstdate: [],
    first2date: [],
    montharrbefore: [],
    monthindex: 0,
    color: ['#e4dfd7', '#f9f4dc', '#f7e8aa', '#f7e8aa', '#f8df72', '#fcd217', '#fcc515', '#f28e16', '#fb8b05', '#d85916', '#f43e06']
  },
  methods: {
    selectStyle(data, event) {
      document.querySelector('.angle-wrapper').style.display = 'block'
      this.span1 = data.date;
      this.span2 = data.count;
      this.x = event.clientX - 100;
      this.y = event.clientY - 60
    },
    outStyle() {
      document.querySelector('.angle-wrapper').style.display = 'none'
    },
    thiscolor(x) {
      if (x === 0) {
        let i = parseInt(x / 2);
        return this.color[0]
      } else if (x < 2) {
        return this.color[1]
      } else if (x < 20) {
        let i = parseInt(x / 2);
        return this.color[i]
      } else {
        return this.color[9]
      }
    },
  }
});
var apiurl = 'python-github-calendar-api-nine.vercel.app' ? 'https://python-github-calendar-api-nine.vercel.app/api?' : 'https://githubapi.ryanchristian.dev/user/'
var githubapiurl = apiurl + gitcalendar.user;
//canvas绘图
function responsiveChart() {
  let c = document.getElementById("gitcanvas");
  if (c) {
    let cmessage = document.getElementById("gitmessage");
    let ctx = c.getContext("2d");
    c.width = document.getElementById("gitcalendarcanvasbox").offsetWidth;
    let linemaxwitdh = 0.96 * c.width / gitcalendar.data.length;
    c.height = 9 * linemaxwitdh;
    let lineminwitdh = 0.8 * linemaxwitdh;
    let setposition = {
      x: 0.02 * c.width,
      y: 0.025 * c.width
    };
    for (let week in gitcalendar.data) {
      weekdata = gitcalendar.data[week];
      for (let day in weekdata) {
        let dataitem = {
          date: "",
          count: "",
          x: 0,
          y: 0
        };
        gitcalendar.positionplusdata.push(dataitem);
        ctx.fillStyle = gitcalendar.thiscolor(weekdata[day].count);
        setposition.y = Math.round(setposition.y * 100) / 100;
        dataitem.date = weekdata[day].date;
        dataitem.count = weekdata[day].count;
        dataitem.x = setposition.x;
        dataitem.y = setposition.y;
        ctx.fillRect(setposition.x, setposition.y, lineminwitdh, lineminwitdh);
        setposition.y = setposition.y + linemaxwitdh
      };
      setposition.y = 0.025 * c.width;
      setposition.x = setposition.x + linemaxwitdh
    };
    ctx.font = "600  Arial";
    ctx.fillStyle = '#aaa';
    ctx.fillText("日", 0, 1.9 * linemaxwitdh);
    ctx.fillText("二", 0, 3.9 * linemaxwitdh);
    ctx.fillText("四", 0, 5.9 * linemaxwitdh);
    ctx.fillText("六", 0, 7.9 * linemaxwitdh);
    let monthindexlist = c.width / 24;
    for (let index in gitcalendar.monthchange) {
      ctx.fillText(gitcalendar.monthchange[index], monthindexlist, 0.7 * linemaxwitdh);
      monthindexlist = monthindexlist + c.width / 12
    };
    cmessage.onmousemove = function(event) {
      document.querySelector('.angle-wrapper').style.display = 'none'
    };
    c.onmousemove = function(event) {
      document.querySelector('.angle-wrapper').style.display = 'none'
      getMousePos(c, event);
    };

    function getMousePos(canvas, event) {
      var rect = canvas.getBoundingClientRect();
      var x = event.clientX - rect.left * (canvas.width / rect.width);
      var y = event.clientY - rect.top * (canvas.height / rect.height);
      //console.log("x:"+x+",y:"+y);
      for (let item of gitcalendar.positionplusdata) {
        let lenthx = x - item.x;
        let lenthy = y - item.y;
        //console.log(lenthx,lenthy);
        if (0 < lenthx && lenthx < lineminwitdh) {
          if (0 < lenthy && lenthy < lineminwitdh) {
            //console.log(item.date,item.count)
            document.querySelector('.angle-wrapper').style.display = 'block'
            gitcalendar.span1 = item.date;
            gitcalendar.span2 = item.count;
            gitcalendar.x = event.clientX - 100;
            gitcalendar.y = event.clientY - 60
          }
        }
        //if(0< x - item.x <lineminwitdh&&0< y - item.y <lineminwitdh){
        //console.log(item.count,item.date);
        //}
      }
    }
  }
}
//数据统计算法
function addlastmonth() {
  if (gitcalendar.thisdayindex === 0) {
    thisweekcore(52);
    thisweekcore(51);
    thisweekcore(50);
    thisweekcore(49);
    thisweekcore(48);
    gitcalendar.thisweekdatacore += gitcalendar.firstdate[6].count;
    gitcalendar.amonthago = gitcalendar.firstdate[6].date
  } else {
    thisweekcore(52);
    thisweekcore(51);
    thisweekcore(50);
    thisweekcore(49);
    thisweek2core();
    gitcalendar.amonthago = gitcalendar.first2date[gitcalendar.thisdayindex - 1].date
  }
};

function thisweek2core() {
  for (let i = gitcalendar.thisdayindex - 1; i < gitcalendar.first2date.length; i++) {
    gitcalendar.thisweekdatacore += gitcalendar.first2date[i].count
  }
};

function thisweekcore(index) {
  for (let item of gitcalendar.data[index]) {
    gitcalendar.thisweekdatacore += item.count
  }
};

function addlastweek() {
  for (let item of gitcalendar.lastweek) {
    gitcalendar.weekdatacore += item.count
  }
};

function addbeforeweek() {
  for (let i = gitcalendar.thisdayindex; i < gitcalendar.beforeweek.length; i++) {
    gitcalendar.weekdatacore += gitcalendar.beforeweek[i].count
  }
};

function addweek(data) {
  if (gitcalendar.thisdayindex === 6) {
    gitcalendar.aweekago = gitcalendar.lastweek[0].date;
    addlastweek()
  } else {
    lastweek = data.contributions[51];
    gitcalendar.aweekago = lastweek[gitcalendar.thisdayindex + 1].date;
    addlastweek();
    addbeforeweek()
  }
}

fetch(githubapiurl)
  .then(data => data.json())
  .then(data => {
    gitcalendar.data = data.contributions;
    gitcalendar.total = data.total;
    gitcalendar.first2date = gitcalendar.data[48];
    gitcalendar.firstdate = gitcalendar.data[47];
    gitcalendar.firstweek = data.contributions[0];
    gitcalendar.lastweek = data.contributions[52];
    gitcalendar.beforeweek = data.contributions[51];
    gitcalendar.thisdayindex = gitcalendar.lastweek.length - 1;
    gitcalendar.thisday = gitcalendar.lastweek[gitcalendar.thisdayindex].date;
    gitcalendar.oneyearbeforeday = gitcalendar.firstweek[0].date;
    gitcalendar.monthindex = gitcalendar.thisday.substring(5, 7) * 1;
    gitcalendar.montharrbefore = gitcalendar.month.splice(gitcalendar.monthindex, 12 - gitcalendar.monthindex);
    gitcalendar.monthchange = gitcalendar.montharrbefore.concat(gitcalendar.month);
    addweek(data);
    addlastmonth();
    responsiveChart();
  })
  .catch(function(error) {
    console.log(error);
  });

//手机版更换为svg绘制
if (document.getElementById("gitcalendarcanvasbox").offsetWidth < 500) {
  gitcalendar.simplemode = false
}

//当改变窗口大小时重新绘制canvas
window.onresize = function() {
  if (gitcalendar.simplemode) responsiveChart()
}

//解决滚动滑轮时出现的标签显示
window.onscroll = function() {
  if (document.querySelector('.angle-wrapper')) {
    document.querySelector('.angle-wrapper').style.display = 'none'
  }
};</script></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/live2d-widget/autoload.js"></script><script async src="https://cdn.jsdelivr.net/gh/lete114/CDN/Sum/title.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="/news/js/keys.js"></script><script defer data-pjax src="/news/js/news.js"></script><div class="aplayer no-destroy" data-id="6822064991" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script src="//code.tidio.co/x1quuahdcuhkubwsyyqe4ug1m0jbfoqn.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"]):not([href="/movies/"]):not([href="/bb/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item =>{
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})</script><div class="GalMenu GalDropDown"><div class="circle" id="gal"><div class="ring"><a class="menuItem" href="/random/"><span>随机文章</span></a><a class="menuItem" href="javascript:location.reload();"><span>刷新</span></a><a class="menuItem" href="javascript:history.go(1);"><span>前进</span></a><a class="menuItem" href="javascript:history.go(-1);"><span>后退</span></a><a class="menuItem" href="#"><span>返回顶部</span></a><a class="menuItem" href="/hpptalk/"><span>说说</span></a></div></div><audio id="audio" src="https://cdn.jsdelivr.net/gh/Akilarlxh/Akilarlxh.github.io@v3.3.3_3/galmenu/galmenu.mp3"></audio></div><script defer="defer" src="https://cdn.jsdelivr.net/gh/Akilarlxh/Akilarlxh.github.io@bf_3.3.0_12/js/custom/galmenu.min.js"></script></div></body></html>